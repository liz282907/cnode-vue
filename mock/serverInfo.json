{"success":true,"data":[{"id":"581b0c4ebb9452c9052e7acb","author_id":"5110f2bedf9e9fcc584e4677","tab":"share","content":"<div class=\"markdown-text\"><p>GitHub: <a href=\"https://github.com/nswbmw/N-blog\">https://github.com/nswbmw/N-blog</a></p>\n<h2>目录</h2>\n<ul>\n<li>开发环境搭建\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/1.1%20Node.js%20%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8.md\">Node.js 的安装与使用</a>\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/1.1%20Node.js%20%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8.md#111-%E5%AE%89%E8%A3%85-nodejs\">安装 Node.js</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/1.1%20Node.js%20%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8.md#112-n-%E5%92%8C-nvm\">n 和 nvm</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/1.1%20Node.js%20%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8.md#113-nrm\">nrm</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/1.2%20MongoDB%20%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8.md\">MongoDB 的安装与使用</a>\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/1.2%20MongoDB%20%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8.md#121-%E5%AE%89%E8%A3%85%E4%B8%8E%E5%90%AF%E5%8A%A8-mongodb\">安装与启动 MongoDB</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/1.2%20MongoDB%20%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8.md#122-robomongo-%E5%92%8C-mongochef\">Robomongo 和 MongoChef</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Node.js 知识点讲解\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/2.1%20require.md\">require</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/2.2%20exports%20%E5%92%8C%20module.exports.md\">exports 和 module.exports</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/2.3%20Promise.md\">Promise</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/2.4%20%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.md\">环境变量</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/2.5%20package.json.md\">packge.json</a>\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/2.5%20package.json.md#251-semver\">semver</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/2.6%20npm%20%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.md\">npm 使用注意事项</a>\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/2.6%20npm%20%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.md#261-npm-init\">npm init</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/2.6%20npm%20%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.md#262-npm-install\">npm install</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/2.6%20npm%20%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.md#263-npm-scripts\">npm scripts</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/2.6%20npm%20%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.md#264-npm-shrinkwrap\">npm shrinkwrap </a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Hello, Express\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/3.1%20%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AA%20Express%20%E9%A1%B9%E7%9B%AE.md\">初始化一个 Express 项目</a>\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/3.1%20%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AA%20Express%20%E9%A1%B9%E7%9B%AE.md#311-supervisor\">supervisor</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/3.2%20%E8%B7%AF%E7%94%B1.md\">路由</a>\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/3.2%20%E8%B7%AF%E7%94%B1.md#321-expressrouter\">express.Router</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/3.3%20%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E.md\">模板引擎</a>\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/3.3%20%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E.md#331-ejs\">ejs</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/3.3%20%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E.md#332-includes\">includes</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/3.4%20Express%20%E6%B5%85%E6%9E%90.md\">Express 浅析</a>\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/3.4%20Express%20%E6%B5%85%E6%9E%90.md#341-%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E-next\">中间件与 next</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/3.4%20Express%20%E6%B5%85%E6%9E%90.md#342-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86\">错误处理</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>一个简单的博客\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.1%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.md\">开发环境</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.2%20%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C.md\">准备工作</a>\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.2%20%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C.md#421-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84\">目录结构</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.2%20%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C.md#422-%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E6%A8%A1%E5%9D%97\">安装依赖模块</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.3%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.md\">配置文件</a>\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.3%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.md#431-config-lite\">config-lite</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.4%20%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1.md\">功能设计</a>\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.4%20%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1.md#441-%E5%8A%9F%E8%83%BD%E4%B8%8E%E8%B7%AF%E7%94%B1%E8%AE%BE%E8%AE%A1\">功能与路由设计</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.4%20%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1.md#442-%E4%BC%9A%E8%AF%9D\">会话</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.4%20%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1.md#443-%E9%A1%B5%E9%9D%A2%E9%80%9A%E7%9F%A5\">页面通知</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.4%20%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1.md#444-%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6\">权限控制</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.5%20%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1.md\">页面设计</a>\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.5%20%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1.md#451-%E7%BB%84%E4%BB%B6\">组件</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.5%20%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1.md#452-applocals-%E5%92%8C-reslocals\">app.locals 和 res.locals</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.6%20%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93.md\">连接数据库</a>\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.6%20%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93.md#461-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-mongolass\">为什么使用 Mongolass</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.7%20%E6%B3%A8%E5%86%8C.md\">注册</a>\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.7%20%E6%B3%A8%E5%86%8C.md#471-%E7%94%A8%E6%88%B7%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1\">用户模型设计</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.7%20%E6%B3%A8%E5%86%8C.md#472-%E6%B3%A8%E5%86%8C%E9%A1%B5\">注册页</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.7%20%E6%B3%A8%E5%86%8C.md#473-%E6%B3%A8%E5%86%8C%E4%B8%8E%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0\">注册与文件上传</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.8%20%E7%99%BB%E5%87%BA%E4%B8%8E%E7%99%BB%E5%BD%95.md\">登出与登录</a>\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.8%20%E7%99%BB%E5%87%BA%E4%B8%8E%E7%99%BB%E5%BD%95.md#481-%E7%99%BB%E5%87%BA\">登出</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.8%20%E7%99%BB%E5%87%BA%E4%B8%8E%E7%99%BB%E5%BD%95.md#482-%E7%99%BB%E5%BD%95%E9%A1%B5\">登录页</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.8%20%E7%99%BB%E5%87%BA%E4%B8%8E%E7%99%BB%E5%BD%95.md#483-%E7%99%BB%E5%BD%95\">登录</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.9%20%E6%96%87%E7%AB%A0.md\">文章</a>\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.9%20%E6%96%87%E7%AB%A0.md#491-%E6%96%87%E7%AB%A0%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1\">文章模型设计</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.9%20%E6%96%87%E7%AB%A0.md#492-%E5%8F%91%E8%A1%A8%E6%96%87%E7%AB%A0\">发表文章</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.9%20%E6%96%87%E7%AB%A0.md#493-%E4%B8%BB%E9%A1%B5%E4%B8%8E%E6%96%87%E7%AB%A0%E9%A1%B5\">主页与文章页</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.9%20%E6%96%87%E7%AB%A0.md#494-%E7%BC%96%E8%BE%91%E4%B8%8E%E5%88%A0%E9%99%A4%E6%96%87%E7%AB%A0\">编辑与删除文章</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.10%20%E7%95%99%E8%A8%80.md\">留言</a>\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.10%20%E7%95%99%E8%A8%80.md#4101-%E7%95%99%E8%A8%80%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1\">留言模型设计</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.10%20%E7%95%99%E8%A8%80.md#4102-%E6%98%BE%E7%A4%BA%E7%95%99%E8%A8%80\">显示留言</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.10%20%E7%95%99%E8%A8%80.md#4103-%E5%8F%91%E8%A1%A8%E4%B8%8E%E5%88%A0%E9%99%A4%E7%95%99%E8%A8%80\">发表与删除留言</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.11%20404%20%E9%A1%B5%E9%9D%A2.md\">404页面</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.12%20%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2.md\">错误页面</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.13%20%E6%97%A5%E5%BF%97.md\">日志</a>\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.13%20%E6%97%A5%E5%BF%97.md#4131-winston-%E5%92%8C-express-winston\">winston 和 express-winston</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.13%20%E6%97%A5%E5%BF%97.md#4132-gitignore\">.gitignore</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.14%20%E6%B5%8B%E8%AF%95.md\">测试</a>\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.14%20%E6%B5%8B%E8%AF%95.md#4141-mocha-%E5%92%8C-supertest\">mocha 和 supertest</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.14%20%E6%B5%8B%E8%AF%95.md#4142-%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87\">测试覆盖率</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.15%20%E9%83%A8%E7%BD%B2.md\">部署</a>\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.15%20%E9%83%A8%E7%BD%B2.md#4151-%E7%94%B3%E8%AF%B7-mlab\">申请 MLab</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.15%20%E9%83%A8%E7%BD%B2.md#4152-pm2\">pm2</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.15%20%E9%83%A8%E7%BD%B2.md#4152-%E9%83%A8%E7%BD%B2%E5%88%B0-heroku\">部署到 Heroku</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.15%20%E9%83%A8%E7%BD%B2.md#4153-%E9%83%A8%E7%BD%B2%E5%88%B0-ucloud\">部署到 UCloud</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>","title":"《一起学 Node.js》彻底重写完毕","last_reply_at":"2016-11-12T07:12:05.514Z","good":false,"top":true,"reply_count":55,"visit_count":5210,"create_at":"2016-11-03T10:07:10.155Z","author":{"loginname":"nswbmw","avatar_url":"https://avatars.githubusercontent.com/u/4279697?v=3&s=120"}},{"id":"581026cceae2a24f34e67f0a","author_id":"54009f5ccd66f2eb37190485","tab":"share","content":"<div class=\"markdown-text\"><h2>历史回顾</h2>\n<p>目前【Node全栈】公众号的粉丝数已破万，对我来说也算完成了一个阶段性的目标吧，做个简单的总结。</p>\n<p><img src=\"//dn-cnode.qbox.me/FmLs9IntmVBFAT-wgAeX5eIB2qND\" alt=\"nodeonly.png\"></p>\n<p>最初，只是想学学运营，公司里专门运营的人不想碰，那就我来吧，CTO就是一块砖，哪里需要哪里搬。我的初衷很简单，我想挑战一下运营，除了编程外，我相信其他的我也一样能够做好。</p>\n<ul>\n<li>注册了公众号</li>\n<li>从以前的文库里，找到《生活如何不无聊》，发了第一篇文章</li>\n<li>将给小弟培训的ppt改改，发了第二篇文章《Nodejs入门教程ppt分享》</li>\n</ul>\n<p>后来就坚持着写，各种小弟们需要了解的实战，大部分都是实践经验，所以在CNode上被alsotang加了很多精华。这本身对我来说也是一种提高，虽然粉丝数寥寥无几，但是还是有效果的。直接推广肯定是大家不喜欢的，于是我在精华帖子下面都加了公众号的二维码</p>\n<p><img src=\"//dn-cnode.qbox.me/Fur5y-wChuXas0dSFQYTKxm4eF5_\" alt=\"qr.png\"></p>\n<p>这招是非常有效的，对于传播来说是非常常见的手段，如果大家自己观察好的公众号文章都会明白的。我的经验也是这样来的。</p>\n<p>在天津是非常难于招人的，尤其是在空港那个位置，对我而言更是苦不堪言，带去的小弟不愿意呆，本地的又找不上人，那么长此下去就是一个死局。对于一个CTO来说，如果连人都找不到，那就是失职。</p>\n<p>很明显，大家都喜欢跟着大牛一起干，哪怕是学徒都愿意的，这个观点是正确的，能够屈尊这样做的人，也是有抱负的人，我个人是非常看好的。社区里有很多散落的有基础的人，只要稍加培养，就可以变成非常得力的帮手。</p>\n<p>但酒香还怕巷子深啊，于是，我就把注意力转移到公众号上，利用粉丝效应，为自己招人。以前我可以睡到8点，可是为了写公众号文章，我就必须7点起来，趴在床上写文章，最好是赶在大家在路上的时候能够看到，这样打开率会高一些。</p>\n<blockquote>\n<p>那是一段很苦，但很快乐的日子</p>\n</blockquote>\n<p>我坚持了很久，粉丝数也明显的上升，突破1千，2千。。。内心还是很激动的。我觉得我对自己的挑战算是成功的，以一个程序员的水平将运营做到这种地步，也还算可圈可点了吧。</p>\n<p>其实光有文章和公众号是不够的，粉丝是要聚集的，你要能够和他们活动才有价值。这也非常符合我招人的初衷。于是成了Node全栈的群，很多朋友都是在这里聊起来的。慢慢的，你会发现，除了互动外，对于文章的打开率也是非常有好处的。发了篇公众号，然后转到群里了，大家讨论讨论也还是很愉快的事儿。</p>\n<p>招人效果也是不错的，慢慢的有人开始找我，咨询是否需要招人，当我告诉他们在天津的时候，大部分人都只能观望了。我是能够理解他们的，离开舒适区是多么难得事儿。但是对我而言，至少有人知道我在招人，这无疑也是一种成就。像德龙、祖宽、文能等好兄弟，都是因此相识的。</p>\n<p>但影响力就这么大，社区就这么大，又是一个极其专业的领域，想要做的更大是很难的事儿，这也是我遇到的瓶颈。通过精华帖以及信任，alsotang给了我CNode的管理员权限，我大学的时候就对社区非常了解，所以一切也算轻车熟路。那么，下一步该怎么做呢？我也是很迷茫的</p>\n<p>由于一直欠薪创业，再加上结婚等，我连吃饭的钱都快没有了，媳妇在老家，我又不好意思张口要，真是很难受的省吃俭用，后来没办法，我就发起了一次培训<a href=\"https://cnodejs.org/topic/5636b5558c67728402553335\">《高效编码习惯训练班（vsc为主，含Nodejs调试技巧）》</a>\n当时招上来10个人，算是解了我的燃眉之急。这就是后来我在github上的vsc文档的基础，目前也超过200多个star了。我也算是vscode在国内推广比较早的人吧，对这个趋势还是判断的比较准的。</p>\n<p>后来StuQ就找到了我，做了几次技术分享，比如《Node.js最新技术栈之Promise》，《Gulp实战和原理解析》等，StuQ做的推广，我也利用公众号做了推广，由于这几篇文章内容还不错，所以大家的口碑也不错，觉得简单易懂，各种好评也都到了StuQ那边。</p>\n<p>后来就合作了《Node.js微信开发》课程，我发现这其实也是个不错的招人方式，想学习的人，培训完了，也可以招到公司来嘛。我还是本着我做的做事原则，做啥都尽力做，不要给自己留下遗憾，准备这个课件也是挺费力的事儿。白天忙工作，晚上把一部分经验整理出来，形成后来的课件。每次都是在讲课前还在修改文档，讲的时候还会现场发挥，所以很多时候都超过1小时。好在大家还都比较喜欢听。写的东西和讲的东西是不一样的，我也从中获益良多。</p>\n<p>对我而言，产出更好的原创内容，才能有更多粉丝。精华帖和教程都很重要。最重要的是要有原创的干货。后来博文视点的编辑主动找我，签下了2本书约和一本翻译。公司的框架，开源了，也就是moajs的前身。各种总结的文档也都在CNode上是精华帖，偶尔会去oschina上的博客上蹭个头条，粉丝数平稳的的增长，线上基本也就这样了。</p>\n<p>于是我把目标转移到了线下，参加了海良组织的几次北京的NodeParty，分享一些内容，解答一些大家的疑问。兄弟们人都非常好，也非常给面子，小圈子也是社交，我也很喜欢在演讲时的心惊肉跳，都是经验嘛。我以前带过很大团队，给他们分享和在外面分享是不一样。陌生而刺激。以前跟很多人一样，想了很多上台就没话了。可是工作都快10年了，有了足够多的积累，可以讲的想讲的话也就多了，也算是厚积薄发的一个过程吧。</p>\n<p>演讲的内容也是非常好的公众号材料啊，偶尔曝光个活动，大家的互动也会相应增加的。慢慢的我也就多参与一些活动，<a href=\"http://xn--live-957f.nodejs.org\">像live.nodejs.org</a>、ningjs、野狗，开源年会这样的活动，增加个人影响力是对公众号的非常的手段，常见逻辑，因为喜欢你这个人，才会关注你的公众号。我算是一个工作狂吧，有时胡子都不刮就直接上去讲，大家都觉得像金刚狼，于是就有狼叔这个雅号。我本来是不喜欢的，可是换个角度，能够让大家娱乐，也未尝不是一件好事吗？后来在公众号里加入了不少娱乐的成分，我一直觉得，干什么都要能够玩出乐趣，如果没乐趣还不如不做。对于公众号也是，别人看你的公众号只有干货，早晚会噎死的。要让人觉得舒服，要让愿意看，这是挺难的事儿。我并不擅长搞笑，素有行走的冰箱之称。我只能自己安慰自己说尽力就好。</p>\n<p>所有这些，其实就是在公众号提供素材，于是题材也变得宽泛了很多</p>\n<ul>\n<li>原创文章《浅出Promise与Api封装》《【Node.js Koa源码解析】co@4.6版本源码解析》</li>\n<li>转载CNode好的文章活动《【社区精选】7 天 600 stars， Mobi.css 是如何诞生的》、《用Node.js的CTO是写代码的，想看看他的经历么？》、《【推荐活动】Nodejs区块链开发作者imfly邀您茶话》</li>\n<li>答疑类的《为啥Koa 2.x要多出个ctx？》</li>\n<li>点评或者正名之类的文章，比如《个人讣告，与Node何干？为莫名躺枪的Node.js正名》</li>\n<li>新闻《GitHub发布2016年开源报告》、《Node.js 7.0安装体验和示例代码解读》</li>\n<li>个人动态《最近的2场分享》、《前一阵做的3个分享》《昨天狼叔直播的微信小程序讲义，据说效果不错哦》《狼叔的jsconf 2016总结：Moa 2开源》《6-18 野狗Meetup技术沙龙，他们都来了！》</li>\n<li>娱乐的<a href=\"http://mp.weixin.qq.com/s?__biz=MzAxMTU0NTc4Nw==&amp;tempkey=JSd6eLNNty57%2BJV%2F%2BLdIll6q%2Ft0DDWazkDY0HBArqGitcN6CTbD15Dt%2BybqZl9E8JGHTzxiuGYngcZy8KWwMX8QcN0tH8qA8Ow7jsozfePSI9W3yZW8Ez9LsTgqQV03JmN8gTPifu2X%2FGs01AYWdpQ%3D%3D&amp;#rd\">《年度最期待大片，《狼叔前传》首部预告片》</a>，《【脑洞大开笑死你】之：什么狗不掉毛？》、《1024节日快乐！嗨起来~》</li>\n<li>蹭热点《未来是h5的：写在微信应用号发布之际》</li>\n<li>组织一些活动《今晚直播聊聊Koa（7月4日 周一晚9点 ）》</li>\n</ul>\n<p>总体来说，做的不那么精细，只有我一个人在维护，我并没有太多时间，我还要写代码，当一个被坑的cto，公众号运营做的不是很好。感谢大家的包容和忍受。</p>\n<p>因为和公司股权的问题，我从有股份变成了1万元每月的打工者，也是醉醉的，合同又让我弄丢了，官司也没法打，我能说的是大家一定要好好保存合同。<strong>感谢各位兄弟的信任，天津的公司不会再招人了，我也不会跟无耻的人有任何关系</strong>。我的书也没有写完，对不住春雨编辑，我的课程也天天被海角催，辛苦你们了。但生活还得继续，我还要工作，不能在公众号上花费太多时间。我希望大家都说“狼叔是个架构师”，而不是自媒体，骨子里我还是做技术的程序员，偶尔还懂点运营。</p>\n<p>我也深知，运营一个公众号打单独斗是不够，是需要有团队配合的。</p>\n<p>在此，Node全栈公众号粉丝破万之际，我也已经完成了我个人的初衷。我想把Node全栈公众号捐给cnode社区，以社区的名义一起来维护。公众号很早就有了原创打赏功能，破万之后有了流量主即广告收入，虽然没多少钱，也一并捐给社区。</p>\n<p>立2个规矩：</p>\n<ul>\n<li>公众号所发文章必须是cnode上的文章</li>\n<li>对cnode社区发展有利</li>\n</ul>\n<p>由于无法直接修改账号本体，我把打赏的数目发出来，作为基数，以后增加的所有收入会捐给社区，所有的商务合作，请联系alsotang@gmail.com</p>\n<p><img src=\"//dn-cnode.qbox.me/Fh6HxtgYYjxL_vJJ1sk_wraU0Ay6\" alt=\"money.png\"></p>\n<p>同时，如果你也感兴趣运营，想和我一起运营好cnode社区的微信公众号，如果你也认为为社区服务也是很快的一件事儿，可以加我一起聊聊，除了技术、评论、搞笑外，我希望我们还是好朋友，我也会尽我所能给你提供各种支持。</p>\n<h2>加入我们</h2>\n<p>加入我们，你将获得</p>\n<ul>\n<li>积累社区经验、威望</li>\n<li>提升运营水平，虽然粉丝不是特别多，但也不算太少了，是个不错的起点</li>\n<li>和cnode大牛、管理员们近距离接触</li>\n<li>更有被内推bat的机会</li>\n</ul>\n<p>赶快报名吧，发送邮件到 <a href=\"mailto:i5ting@126.com\">i5ting@126.com</a> 并抄送 <a href=\"mailto:alsotang@gmail.com\">alsotang@gmail.com</a></p>\n<p>请在邮件中注明</p>\n<ul>\n<li>社区id</li>\n<li>目前公司+职位或学校+专业</li>\n<li>平时在社区的贡献或技术博客展示，或github页面</li>\n<li>对于社区运营的想法</li>\n</ul>\n</div>","title":"【Node全栈】升级为CNode官方公众号，招收喜欢运营的小伙伴","last_reply_at":"2016-11-11T09:23:09.033Z","good":false,"top":true,"reply_count":26,"visit_count":3605,"create_at":"2016-10-26T03:45:16.426Z","author":{"loginname":"i5ting","avatar_url":"https://avatars.githubusercontent.com/u/3118295?v=3&s=120"}},{"id":"580ddc2eeae2a24f34e67e69","author_id":"504c28a2e2b845157708cb61","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FjfPMJYFAbyV1-OM-CcCC5Wk2tmY\" alt=\"江湖网页版01.jpg\">\n<img src=\"//dn-cnode.qbox.me/FkwjibIXclB7i5988nqIU2Urdot6\" alt=\"江湖网页版02.jpg\">\n<img src=\"//dn-cnode.qbox.me/FtrbZGh5EhRj9F5Gqf6zxoaAtAdu\" alt=\"江湖网页版03.jpg\">\n<img src=\"//dn-cnode.qbox.me/FoG0Zu0fTUGQovqVTHpY-mpKg_DD\" alt=\"江湖网页版04.jpg\">\n<img src=\"//dn-cnode.qbox.me/FjNEtfvguZpaMbSFdfqWEWa0WaKi\" alt=\"江湖网页版05.jpg\">\n<img src=\"//dn-cnode.qbox.me/Fv7Gn_eSisMoWjcg1tY30tpyYBH7\" alt=\"江湖网页版06.jpg\">\n<img src=\"//dn-cnode.qbox.me/FkrxD4s4PIWDCyfEAb7-fAXyaCkI\" alt=\"江湖网页版07.jpg\">\n<img src=\"//dn-cnode.qbox.me/Fp2Rnl5M_UcmDZCVEB7hrEk1Pw84\" alt=\"江湖网页版08.jpg\">\n<img src=\"//dn-cnode.qbox.me/Fs87hfP9Sd44vsLYCxX5mfZCojEg\" alt=\"江湖网页版09.jpg\"></p>\n<p>社区加盟报名表：<a href=\"http://form.mikecrm.com/rbWwV4\">http://form.mikecrm.com/rbWwV4</a></p>\n</div>","title":"这，就是技术人的江湖","last_reply_at":"2016-11-10T15:59:10.621Z","good":false,"top":true,"reply_count":15,"visit_count":5417,"create_at":"2016-10-24T10:02:22.775Z","author":{"loginname":"alsotang","avatar_url":"https://avatars.githubusercontent.com/u/1147375?v=3&s=120"}},{"id":"57ea257b3670ca3f44c5beb6","author_id":"541bf9b9ad60405c1f151a03","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>写在头部</p>\n</blockquote>\n<p>本项目写于小程序发布之初，期间小程序官方有过几次更新，例如准备移除了loading组件、改变page的默认高度等，主要看的还是博卡君的文章，后来在朋友的建议下在9月27号写了本篇文章并分享到github上，是做为微信小应用的入门教程，<strong>并非某在线学习网站499收费课程的作业</strong>，特此声明。</p>\n<blockquote>\n<p>微信应用号入门实践之cnode社区版</p>\n</blockquote>\n<p>首先感谢cnode社区提供的api，本次实现了简单的cnode社区应用号制作。\n实现了数据的读取、展示，\n实现了简单的布局，\n实现了下一页功能。</p>\n<p>放上我的github地址\n<a href=\"https://github.com/coolfishstudio/wechat-webapp-cnode\">https://github.com/coolfishstudio/wechat-webapp-cnode</a></p>\n<p><img src=\"//dn-cnode.qbox.me/Fo4zG2Vfe50352POPZYXv8Ls0Jcc\" alt=\"首页列表\">\n<img src=\"//dn-cnode.qbox.me/Fl7TiaW13s541lHZ7Crq7NxKshqG\" alt=\"内容详情\"></p>\n<p>下面就说说我做这个的过程，不足之处，请多多指教，只愿为进步。</p>\n<h2>1.创建项目</h2>\n<p>首先，在官网下载工具，<a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html?t=1474887501214\">下载地址</a> 我的是选择mac版本0.9.092300。</p>\n<p>然后跟着官方的<a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/?t=1474887501301\">简版教程</a> 创建一个项目。</p>\n<h4>注：现在官方的工具支持无appid创建项目。</h4>\n<h5>1.打开开发者工具，选择“添加项目”</h5>\n<p><img src=\"//dn-cnode.qbox.me/FsqxRNIzNDyzItbl-vhAFPr0J5t2\" alt></p>\n<h5>2.选择无appid，填写地址，创建项目</h5>\n<p><img src=\"//dn-cnode.qbox.me/Fp098WRAyxgJ415Dt_f0YGhjIMHr\" alt></p>\n<h5>3.创建成功，看到默认的Demo项目页面</h5>\n<p><img src=\"//dn-cnode.qbox.me/FuvUmKfcUu8MeLc4eeuwNBfkbfMC\" alt></p>\n<h2>2.配置</h2>\n<p>默认的项目里已经没有关于tabBar的配置信息，所以为了学习，我把这个配置进行了修改。</p>\n<p>首先关于配置的说明同样来自于<a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html?t=1474887501556\">官方</a></p>\n<p>注意：官方的代码有些字段是不一样的，小心被坑。</p>\n<pre class=\"prettyprint\"><code>{\n  &quot;pages&quot;:[\n    &quot;pages&#x2F;index&#x2F;index&quot;,\n    &quot;pages&#x2F;logs&#x2F;logs&quot;\n  ],\n  &quot;window&quot;:{\n    &quot;backgroundTextStyle&quot;:&quot;light&quot;,\n    &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;,\n    &quot;navigationBarTitleText&quot;: &quot;WeChat&quot;,\n    &quot;navigationBarTextStyle&quot;:&quot;black&quot;\n  },\n  &quot;tabBar&quot;:{\n    &quot;list&quot;: [{\n      &quot;pagePath&quot;: &quot;pages&#x2F;index&#x2F;index&quot;,\n      &quot;text&quot;: &quot;首页&quot;\n    }, {\n      &quot;pagePath&quot;: &quot;pages&#x2F;logs&#x2F;logs&quot;,\n      &quot;text&quot;: &quot;日志&quot;\n    }]\n  }\n}\n\n</code></pre><p>增加了tabBar, 查看调试\n<img src=\"//dn-cnode.qbox.me/Fl-OboTDeCULcPbs5BiM81nj_Xrc\" alt>\n看界面是如此的简陋，为此针对tabBar参考官方说明进行了简单的美化。</p>\n<pre class=\"prettyprint\"><code> &quot;tabBar&quot;:{\n    &quot;color&quot;:&quot;#272636&quot;,\n    &quot;selectedColor&quot;:&quot;#80bd01&quot;,\n    &quot;backgroundColor&quot;:&quot;#fff&quot;,\n    &quot;borderStyle&quot;:&quot;white&quot;,\n    &quot;list&quot;:[{\n      &quot;pagePath&quot;:&quot;pages&#x2F;index&#x2F;index&quot;,\n      &quot;text&quot;:&quot;首页&quot;,\n      &quot;iconPath&quot;:&quot;images&#x2F;tabBar&#x2F;my.png&quot;,\n      &quot;selectedIconPath&quot;:&quot;images&#x2F;tabBar&#x2F;my_hl.png&quot;\n    },{\n      &quot;pagePath&quot;:&quot;pages&#x2F;index&#x2F;index&quot;,\n      &quot;text&quot;:&quot;我的&quot;,\n      &quot;iconPath&quot;:&quot;images&#x2F;tabBar&#x2F;list.png&quot;,\n      &quot;selectedIconPath&quot;:&quot;images&#x2F;tabBar&#x2F;list_hl.png&quot;\n    }]\n  }\n</code></pre><p>效果如图\n<img src=\"//dn-cnode.qbox.me/FjzwAq6RH5TstCXIYb5ZIt6z3cuj\" alt>\n最后根据文档，对默认页面的窗口表现进行了修改</p>\n<pre class=\"prettyprint\"><code>  &quot;window&quot;:{\n    &quot;backgroundTextStyle&quot;:&quot;black&quot;,\n    &quot;backgroundColor&quot;:&quot;#fff&quot;,\n    &quot;navigationBarBackgroundColor&quot;:&quot;#000&quot;,\n    &quot;navigationBarTitleText&quot;:&quot;CNODE 应用号版&quot;,\n    &quot;navigationBarTextStyle&quot;:&quot;white&quot;,\n    &quot;enablePullDownRefresh&quot;:&quot;true&quot;\n  },\n</code></pre><p>效果如图\n<img src=\"//dn-cnode.qbox.me/Fl4S7o2m50JXXt1xebSgq1pNR_iX\" alt>\n整体配置文件为</p>\n<pre class=\"prettyprint\"><code>{\n  &quot;pages&quot;:[\n    &quot;pages&#x2F;index&#x2F;index&quot;,\n    &quot;pages&#x2F;logs&#x2F;logs&quot;\n  ],\n  &quot;window&quot;:{\n    &quot;backgroundTextStyle&quot;:&quot;black&quot;,\n    &quot;backgroundColor&quot;:&quot;#fff&quot;,\n    &quot;navigationBarBackgroundColor&quot;:&quot;#000&quot;,\n    &quot;navigationBarTitleText&quot;:&quot;CNODE 应用号版&quot;,\n    &quot;navigationBarTextStyle&quot;:&quot;white&quot;,\n    &quot;enablePullDownRefresh&quot;:&quot;true&quot;\n  },\n  &quot;tabBar&quot;:{\n    &quot;color&quot;:&quot;#272636&quot;,\n    &quot;selectedColor&quot;:&quot;#80bd01&quot;,\n    &quot;backgroundColor&quot;:&quot;#fff&quot;,\n    &quot;borderStyle&quot;:&quot;white&quot;,\n    &quot;list&quot;:[{\n      &quot;pagePath&quot;:&quot;pages&#x2F;index&#x2F;index&quot;,\n      &quot;text&quot;:&quot;首页&quot;,\n      &quot;iconPath&quot;:&quot;images&#x2F;tabBar&#x2F;my.png&quot;,\n      &quot;selectedIconPath&quot;:&quot;images&#x2F;tabBar&#x2F;my_hl.png&quot;\n    },{\n      &quot;pagePath&quot;:&quot;pages&#x2F;index&#x2F;index&quot;,\n      &quot;text&quot;:&quot;我的&quot;,\n      &quot;iconPath&quot;:&quot;images&#x2F;tabBar&#x2F;list.png&quot;,\n      &quot;selectedIconPath&quot;:&quot;images&#x2F;tabBar&#x2F;list_hl.png&quot;\n    }]\n  }\n}\n</code></pre><h2>3.制作首页列表</h2>\n<p>根据官方要求，我在pages文件夹内创建了topics文件夹，并创建了对应了 topics.js、topics.wxml、topics.wxss 三个文件。</p>\n<h3>1.注册页面</h3>\n<p>首先在配置文件里注册这个topics,</p>\n<pre class=\"prettyprint\"><code>  &quot;pages&quot;:[\n    &quot;pages&#x2F;topics&#x2F;topics&quot;,\n    &quot;pages&#x2F;index&#x2F;index&quot;,\n    &quot;pages&#x2F;logs&#x2F;logs&quot;\n  ],\n</code></pre><p>并且制定tabBar点击跳到对应的topics页面</p>\n<pre class=\"prettyprint\"><code>  &quot;tabBar&quot;:{\n    &quot;color&quot;:&quot;#272636&quot;,\n    &quot;selectedColor&quot;:&quot;#80bd01&quot;,\n    &quot;backgroundColor&quot;:&quot;#fff&quot;,\n    &quot;borderStyle&quot;:&quot;white&quot;,\n    &quot;list&quot;:[{\n      &quot;pagePath&quot;:&quot;pages&#x2F;topics&#x2F;topics&quot;,\n      &quot;text&quot;:&quot;首页&quot;,\n      &quot;iconPath&quot;:&quot;images&#x2F;tabBar&#x2F;my.png&quot;,\n      &quot;selectedIconPath&quot;:&quot;images&#x2F;tabBar&#x2F;my_hl.png&quot;\n    },{\n      &quot;pagePath&quot;:&quot;pages&#x2F;index&#x2F;index&quot;,\n      &quot;text&quot;:&quot;我的&quot;,\n      &quot;iconPath&quot;:&quot;images&#x2F;tabBar&#x2F;list.png&quot;,\n      &quot;selectedIconPath&quot;:&quot;images&#x2F;tabBar&#x2F;list_hl.png&quot;\n    }]\n  }\n</code></pre><h5>注意：我发现注册页面的顺序会影响到默认显示tabBar的顺序，所以我把<code>&quot;pages/topics/topics&quot;</code>放到了<code>&quot;pages/index/index&quot;</code>的前面</h5>\n<p>然后编写topics.js</p>\n<pre class=\"prettyprint\"><code>Page({\n  data: {\n    title: &#x27;首页列表&#x27;\n  },\n  onLoad: function () {\n    console.log(&#x27;onLoad by topics&#x27;);\n  }\n});\n</code></pre><p>以及topics.wxml文件</p>\n<pre class=\"prettyprint\"><code>&lt;view class=&quot;topics-main&quot;&gt;\n  测试首页列表界面\n&lt;&#x2F;view&gt;\n</code></pre><p>和topics.wxss文件</p>\n<pre class=\"prettyprint\"><code>.topics-main {\n  background: #f60;\n  height: 100%;\n}\n</code></pre><p>最后效果如图\n<img src=\"//dn-cnode.qbox.me/FiunQ0XhES_sidHnkBN9YxABF2iI\" alt></p>\n<h3>2.创建请求</h3>\n<p>根据文档<a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/api/network-request.html?t=1474887499445\">请求数据</a>，在util文件夹内创建一个api.js文件，专门进行数据请求处理。</p>\n<pre class=\"prettyprint\"><code>&#x27;use strict&#x27;;\nvar HOST_URI = &#x27;https:&#x2F;&#x2F;cnodejs.org&#x2F;api&#x2F;v1&#x27;;\n\nvar GET_TOPICS = &#x27;&#x2F;topics&#x27;;\nvar GET_TOPIC_BY_ID = &#x27;&#x2F;topic&#x2F;&#x27;;\n\nfunction obj2uri (obj) {\n    return Object.keys(obj).map(function (k) {\n        return encodeURIComponent(k) + &#x27;=&#x27; + encodeURIComponent(obj[k]);\n    }).join(&#x27;&amp;&#x27;);\n}\n\nmodule.exports = {\n    &#x2F;&#x2F; 获取列表数据\n    getTopics: function (obj) {\n        return HOST_URI + GET_TOPICS + &#x27;?&#x27; + obj2uri(obj);\n    },\n    &#x2F;&#x2F; 获取内容页数据\n    getTopicByID: function (id, obj) {\n        return HOST_URI + GET_TOPIC_BY_ID + id + &#x27;?&#x27; + obj2uri(obj);\n    }\n};\n</code></pre><p>修改topics.js</p>\n<pre class=\"prettyprint\"><code>var Api = require(&#x27;..&#x2F;..&#x2F;utils&#x2F;api.js&#x27;);\n\nPage({\n  data: {\n    title: &#x27;首页列表&#x27;\n  },\n  onLoad: function () {\n    console.log(&#x27;onLoad by topics&#x27;);\n    this.fetchData();&#x2F;&#x2F; 获取数据\n  },\n  fetchData: function (data) {\n    &#x2F;&#x2F; 处理参数\n    if (!data) data = {};\n    if (!data.page) data.page = 1;\n    wx.request({\n      url: Api.getTopics(data),\n      success: function (res) {\n        console.log(res);\n      }\n    });\n  }\n});\n</code></pre><p>效果如图\n<img src=\"//dn-cnode.qbox.me/FoonyAMQBgqDpiTKZshoB3ZmnUEU\" alt>\n成功拿到了数据。</p>\n<h3>3.完善首页列表</h3>\n<p>拿到了数据，也能修改界面，那么就直接完善这个首页吧</p>\n<p>代码就不放了，直接上图\n<img src=\"//dn-cnode.qbox.me/Fo4zG2Vfe50352POPZYXv8Ls0Jcc\" alt>\n我认为这里值得说的大概只有loading、循环、传参、下一页和页面跳转了。</p>\n<h4>1.loading</h4>\n<pre class=\"prettyprint\"><code>  &lt;loading hidden=&quot;{{hidden}}&quot;&gt;\n    加载中...\n  &lt;&#x2F;loading&gt;\n</code></pre><p>在topics.wxml中写官方提供的loading组件，根据在topics.js中对hidden值的修改，来触发loading。</p>\n<h4>2.循环数据，展示列表</h4>\n<p>文档提供了<a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/list.html?t=1474887501556\">列表渲染</a></p>\n<p>通过<code>wx:for</code>实现列表的渲染。</p>\n<h5>注意: 默认数组的当前项的下标变量名默认为index，数组当前项的变量名默认为item。</h5>\n<pre class=\"prettyprint\"><code>&lt;block wx:for=&quot;{{postsList}}&quot;&gt;\n  &lt;view class=&quot;posts-item&quot; index=&quot;{{index}}&quot; id=&quot;{{item.id}}&quot; catchtap=&quot;redictDetail&quot;&gt;\n    &lt;view class=&quot;author&quot;&gt;\n      &lt;image class=&quot;author-avatar&quot; src=&quot;{{item.author.avatar_url}}&quot;&gt;&lt;&#x2F;image&gt;\n      &lt;view class=&quot;author-name&quot;&gt;{{item.author.loginname}}&lt;&#x2F;view&gt;\n      &lt;view class=&quot;posts-tag hot&quot; wx:if=&quot;{{item.top === true}}&quot;&gt;置顶&lt;&#x2F;view&gt;\n      &lt;view class=&quot;posts-tag&quot; wx:if=&quot;{{item.good === true}}&quot;&gt;精华&lt;&#x2F;view&gt;\n      &lt;view class=&quot;posts-last-reply&quot;&gt;{{item.last_reply_at}}&lt;&#x2F;view&gt;\n    &lt;&#x2F;view&gt;\n    &lt;view class=&quot;posts-title&quot;&gt;{{item.title}}&lt;&#x2F;view&gt;\n    &lt;view class=&quot;bar-info&quot;&gt;\n      &lt;view class=&quot;bar-info-item&quot;&gt;\n        &lt;image class=&quot;bar-info-item-icon&quot; src=&quot;&#x2F;images&#x2F;icon&#x2F;reply.png&quot;&gt;&lt;&#x2F;image&gt;\n        &lt;view class=&quot;bar-info-item-number&quot;&gt;{{item.reply_count}}&lt;&#x2F;view&gt;\n      &lt;&#x2F;view&gt;\n      &lt;view class=&quot;bar-info-item&quot;&gt;\n        &lt;image class=&quot;bar-info-item-icon&quot; src=&quot;&#x2F;images&#x2F;icon&#x2F;visit.png&quot;&gt;&lt;&#x2F;image&gt;\n        &lt;view class=&quot;bar-info-item-number&quot;&gt;{{item.visit_count}}&lt;&#x2F;view&gt;\n      &lt;&#x2F;view&gt;\n    &lt;&#x2F;view&gt;\n  &lt;&#x2F;view&gt;\n&lt;&#x2F;block&gt;\n</code></pre><p>附上一个没有样式的列表展现\n<img src=\"//dn-cnode.qbox.me/FkoTZY1Q9kqOWa1-e70FHifzHVo7\" alt></p>\n<h4>3.传参，实现tab切换</h4>\n<p>根据cnode的api可以知道通过tab不同的值，获得到不同标签下的内容列表。</p>\n<p>所以 在页面的最上面 tab 栏中</p>\n<pre class=\"prettyprint\"><code>  &lt;view class=&quot;top-bar&quot;&gt;\n    &lt;view class=&quot;top-bar-item&quot; id=&quot;all&quot; catchtap=&quot;onTapTag&quot;&gt;全部&lt;&#x2F;view&gt;\n    &lt;view class=&quot;top-bar-item&quot; id=&quot;good&quot; catchtap=&quot;onTapTag&quot;&gt;精华&lt;&#x2F;view&gt;\n    &lt;view class=&quot;top-bar-item&quot; id=&quot;share&quot; catchtap=&quot;onTapTag&quot;&gt;分享&lt;&#x2F;view&gt;\n    &lt;view class=&quot;top-bar-item&quot; id=&quot;ask&quot; catchtap=&quot;onTapTag&quot;&gt;问答&lt;&#x2F;view&gt;\n    &lt;view class=&quot;top-bar-item&quot; id=&quot;job&quot; catchtap=&quot;onTapTag&quot;&gt;招聘&lt;&#x2F;view&gt;\n  &lt;&#x2F;view&gt;\n</code></pre><p>将id进行定义，通过获取id拿到对应的tab类型。</p>\n<p>其中<code>catchtap</code>是事件绑定。</p>\n<p>bind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡。</p>\n<p>在topics.js获取</p>\n<pre class=\"prettyprint\"><code>  onTapTag: function (e) {\n    var self = this;\n    var tab = e.currentTarget.id;\n    &#x2F;&#x2F; 这里就能获取到不同的tab值了\n    self.setData({\n      tab: tab\n    });\n    if (tab !== &#x27;all&#x27;) {\n      this.fetchData({tab: tab});\n    } else {\n      this.fetchData();\n    }\n  },\n</code></pre><h4>4.下一页的实现</h4>\n<p>根据文档，组件的视图容器中有<a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/component/scroll-view.html?t=1474887496374\">scroll-view</a>这个可滚动视图区域。</p>\n<h5>注意：使用竖向滚动时，需要给&lt;scroll-view/&gt;一个固定高度。</h5>\n<pre class=\"prettyprint\"><code>&lt;scroll-view class=&quot;posts-list&quot; style=&quot;height:100%&quot; scroll-y=&quot;true&quot; bindscrolltolower=&quot;lower&quot;&gt;\n  &lt;block wx:for=&quot;{{postsList}}&quot;&gt;\n    ...\n  &lt;&#x2F;block&gt;\n&lt;&#x2F;scroll-view&gt;\n</code></pre><p>topics.js文件</p>\n<pre class=\"prettyprint\"><code>  lower: function (e) {\n    var self = this;\n    &#x2F;&#x2F; 修改当前页码\n    self.setData({\n      page: self.data.page + 1\n    });\n    &#x2F;&#x2F; 判断当前页的tab值 进行请求数据\n    if (self.data.tab !== &#x27;all&#x27;) {\n      this.fetchData({tab: self.data.tab, page: self.data.page});\n    } else {\n      this.fetchData({page: self.data.page});\n    }\n  }\n</code></pre><h4>5.跳页的实现</h4>\n<p>在<code>posts-item</code>中已经进行了事件绑定。利用<code>wx.navigateTo</code>实现页面的跳转。</p>\n<h5>注意：一个应用同时只能打开5个页面，当已经打开了5个页面之后，wx.navigateTo不能正常打开新页面。</h5>\n<pre class=\"prettyprint\"><code>redictDetail: function (e) {\n  console.log(&#x27;我要看详情&#x27;);\n  var id = e.currentTarget.id,\n      url = &#x27;..&#x2F;detail&#x2F;detail?id=&#x27; + id;\n      &#x2F;&#x2F; 这里的detail是需要创建对应的文件，以及页面注册的\n  wx.navigateTo({\n    url: url\n  })\n},\n</code></pre><h3>4.实现详情页</h3>\n<p>同样的原理，创建detail文件，并注册，获取数据，并美化页面。\n<img src=\"//dn-cnode.qbox.me/FmJ5n5-t3gLCfFQTpbzIBS1_ag2L\" alt></p>\n<h3>5.总结</h3>\n<ul>\n<li>微信小应用页面的脚本逻辑在是在JsCore中运行，JsCore是一个没有窗口对象的环境，所以不能再脚本中使用window，也无法在脚本中操作组件</li>\n<li>同样不能用jquery</li>\n<li>也不能操作dom</li>\n<li>部分标签不支持，比如 h1-h6 会编译报错。</li>\n<li>暂时没找到解决富文本详情页显示的办法。</li>\n<li>整体下来，感觉开发简单，限制很多。</li>\n<li>写过react的看这个确实比较简单。</li>\n</ul>\n<p>放上我的github地址\n<a href=\"https://github.com/coolfishstudio/wechat-webapp-cnode\">https://github.com/coolfishstudio/wechat-webapp-cnode</a></p>\n<p>最后感谢：cnode社区和博卡君</p>\n<p>附上 博卡君的教程</p>\n<p><a href=\"https://my.oschina.net/wwnick/blog/750055\">全球首个微信应用号开发教程！通宵吐血赶稿，每日更新！</a></p>\n<p><a href=\"https://my.oschina.net/wwnick/blog/750495\">博卡君的应用号（小程序）开发教程首发第二弹！（0923）</a></p>\n<p><a href=\"https://my.oschina.net/wwnick/blog/750974\">第三弹！全球首个微信应用号开发教程！通宵吐血赶稿，每日更新！</a></p>\n<p><a href=\"https://my.oschina.net/wwnick/blog/751826\">第四弹！全球首个微信应用号开发教程！通宵吐血赶稿，每日更新！</a></p>\n<p><a href=\"https://my.oschina.net/wwnick/blog/752421\">第五弹！全球首个微信应用号开发教程！通宵吐血赶稿，每日更新！</a></p>\n<p><a href=\"https://my.oschina.net/wwnick/blog/753597\">第六弹！全球首个微信小程序（应用号）开发教程！通宵吐血赶稿！</a>\n－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－\n总结一下我遇到的问题\n1.页面没有注册 那么 template 模版无法传递数据 拿不到动态数据 但是能使用wxss\n2.进度条注意右侧百分号 100%的时候 进度条缩短\n3.轮播图加上属性vertical=“vertical/horizontal” 可以修改布局方向，文档没说\n4.有关icon，文档提供默认的只有9个，实际目前测出有15个 success, info, warn, waiting, safe_success, safe_warn,success_circle, success_no_circle, waiting_circle, circle, download,info_circle, cancel, search, clear</p>\n</div>","title":"分享我用cnode社区api做微信小应用的入门过程","last_reply_at":"2016-11-07T15:37:13.187Z","good":false,"top":true,"reply_count":102,"visit_count":15190,"create_at":"2016-09-27T07:53:31.872Z","author":{"loginname":"coolfishstudio","avatar_url":"https://avatars.githubusercontent.com/u/8791709?v=3&s=120"}},{"id":"58283df2d3abab717d8b4c00","author_id":"5155a9925dff253b374d1dbe","tab":"share","content":"<div class=\"markdown-text\"><p>  最近在做基础开发框架登录模块的重构，所以来谈一谈关于代码质量的思考。<br>\n  进入正题之前，先吐槽一下，看看能不能引起一点共鸣。<br>\n  之所以要重构这部分的代码，原因很简单，公司的测试团队通过压力测试发现登录这块有性能问题。同时，基于另外一个使用产品基础开发框架的团队需要在登录这块进行一些业务上的扩展。怀着激动的心情打开这块的相关代码，首先第一感觉就是杂乱无章，排版糟糕。没办法，要解决问题，还是得硬着头皮看下去。接着，从前端UI界面的输入到提交看起，发现代码相当的绕，很难看懂其中的逻辑。另外，其中还有大片的冗余拖沓代码。虽然整体功能逻辑完整的实现了，但是实现细节一团糟。毫不夸张的说，很多部分的代码完全属于技术验证阶段的代码。遇到这样的代码，我想很少能有人能静下心来完完整整的看完…</p>\n<p>下面说说我所认为的代码是怎么样的:</p>\n<ol>\n<li>代码需要排版整洁干净、并且有清晰适当的注释，当打开代码源文件的瞬间，能给人一种赏心悦目的感觉。</li>\n<li>代码要简洁，不拖沓，不能为了封装而封装，为了面向对象而面向对象。重复功能的代码尽量封装成方法，杜绝成段成段的相同代码、冗余代码。</li>\n<li>代码的结构要清晰，让其他人能轻松的找到程序的入口，轻松摸清代码的整体脉络，并且不看每个方法中的具体内容，只需要看整个代码的骨骼即能了解程序的功能。</li>\n<li>模块与模块的对接部分要简洁。大部分情况为沟通不彻底或者相互对对方的模块缺乏基本的了解造成。</li>\n<li>注重代码的性能。这一块不仅需要从纯技术角度去考虑代码的性能，还需要深入的了解业务需求，往往一个灵光一闪的想法就能节约成片的代码、以简单的逻辑实现复杂的业务需求。</li>\n</ol>\n<p>一些思考：</p>\n<ol>\n<li>好的代码往往是经过不断的打磨产生的，一个精进的程序员应当具备一颗喜欢折腾代码的躁动的心。</li>\n<li>对于框架级的代码，越早重构越好，越往后拖所带来的成本越大。</li>\n<li>糟糕代码质量的代码后期维护成本不可估量，甚至会影响到后续新功能的开发，从这里真正能对比出一个优秀Programmer的价值。</li>\n<li>写代码也是一门艺术。一段完美精致代码的创造过程不亚于一件艺术品的创作过程。</li>\n</ol>\n</div>","title":"关于代码质量的一点思考","last_reply_at":"2016-11-13T14:04:15.091Z","good":false,"top":false,"reply_count":3,"visit_count":55,"create_at":"2016-11-13T10:18:26.140Z","author":{"loginname":"albert","avatar_url":"//gravatar.com/avatar/17b586bd384e73d7c770143182fdb7e8?size=48"}},{"id":"581050ccb37ee8fb33978821","author_id":"58104b6c1a9a7d9909531149","tab":"job","content":"<div class=\"markdown-text\"><p><strong>公司：</strong> 成都智慕时代科技公司\n<strong>工作地点：</strong> 成都天府新谷10栋17楼\n<strong>招聘职位：</strong> Web 后端开发，Node.js或其他你熟悉的语言\n<strong>待遇：</strong> 正式员工： 8K-15K\n<strong>请将简历发送至：</strong> <a href=\"mailto:oblank@dreamixtech.com\">oblank@dreamixtech.com</a></p>\n<h2>岗位职责</h2>\n<ol>\n<li>参与产品的需求调研和需求分析 ；</li>\n<li>搭建系统开发环境，完成系统框架和核心代码的实现；</li>\n<li>系统开发测试、部署和集成；</li>\n<li>负责解决开发过程中的技术问题；</li>\n</ol>\n<h2>我们的要求</h2>\n<ol>\n<li>熟悉 Web 后端开发， 1 年以上的 PHP/Node.js/Java/C++/Ruby/Python 等语言开发经验；</li>\n<li>熟悉面向对象编程；</li>\n<li>熟悉 SQL 、 NoSQL 等主流数据库；</li>\n<li>有良好的编程风格，能够书写规范、优质的代码；</li>\n<li>良好的团队协作能力；\n6，熟悉基本的Linux服务器命令；</li>\n</ol>\n<h2>公司介绍：</h2>\n<p>做医院内部相关系统，现在主要拓展成都本地的医院，投资人跟委计委关系不错，跟腾讯关系也不错。做了一年时间，大概拿下了 26 家医院，主要集中在成都、绵阳、南充、广元、北京、深圳等。</p>\n<p>产品主要做 web 版、企业号、服务号，主要解决医院内部各种流程、审批与微信的互联互通，病人与医生的互联互通，企业号与服务号的互联互通。</p>\n<p>公司：<a href=\"http://www.runningdoctor.cn\">http://www.runningdoctor.cn</a></p>\n<h2>其他</h2>\n<p>不加班。现在几个人的能力都还不错，没老油条。 公司氛围不错。 能力觉得不错的投，一般有 1-2+年的投。公司发展前景很不错。 前端有 2 个漂亮妹子，产品运营也有漂亮妹子，恩。</p>\n</div>","title":"【成都】招聘2-3人Node.js（待遇8k-15k）","last_reply_at":"2016-11-13T13:54:33.999Z","good":false,"top":false,"reply_count":5,"visit_count":193,"create_at":"2016-10-26T06:44:28.986Z","author":{"loginname":"oblank","avatar_url":"https://avatars.githubusercontent.com/u/2127571?v=3&s=120"}},{"id":"58286ebde885ce5a39382865","author_id":"56daaf5dc0fa23473d005feb","tab":"ask","content":"<div class=\"markdown-text\"><p>一旦因为网络或其他原因，怎么回滚退回前呢？</p>\n</div>","title":"微信支付如何开启事务呢","last_reply_at":"2016-11-13T13:46:37.568Z","good":false,"top":false,"reply_count":0,"visit_count":11,"create_at":"2016-11-13T13:46:37.568Z","author":{"loginname":"zhulinwei","avatar_url":"https://avatars.githubusercontent.com/u/17670262?v=3&s=120"}},{"id":"5808b64427a1d99178a9901e","author_id":"50b5a3f5637ffa415506deb7","tab":"share","content":"<div class=\"markdown-text\"><p>WEPT 是一个微信小程序实时运行环境，它的目标是为小程序开发提供高效、稳定、友好、无限制的运行环境。\n项目地址： <a href=\"https://github.com/chemzqm/wept\">https://github.com/chemzqm/wept</a>\nWEPT 0.3.0 引入一些新的功能，并对之前代码做了一些重构，为了不影响多数用户正常使用，先在 npm 发布测试版进行测试。</p>\n<h2>主要更新如下：</h2>\n<ul>\n<li>添加 支持刷新后导航到之前页面</li>\n<li>添加 支持 app.json 中 navagation 配置和 tabBar 配置热加载</li>\n<li>添加 使用 babel es2015 编译 JavaScript，支持 sourceMap，暂时无法禁用该功能</li>\n<li>添加 支持小程序根目录做为 wept 命令参数</li>\n<li>添加 静态文件 http 缓存支持，降低加载等待时间</li>\n<li>添加 使用 growl 桌面提醒文件重加载</li>\n<li>修复 绝对路径的 wxml template 无法引入 bug #26</li>\n<li>修复 windows 上热更新不可用 bug</li>\n<li>改进 打包并且增量编译 service 层代码</li>\n<li>改进 service 层 javascript 代码构建结果与官方 101400 一致</li>\n<li>改进 使用 gulp 执行前后端代码构建任务</li>\n<li>改进 高亮显示 app.json 找不到提醒</li>\n<li>修改 Mac 下使用 -o 参数时才执行 Chrome 相关脚本打开页面</li>\n<li>修改 右上角菜单的刷新改为返回首页，刷新当前页使用浏览器刷新即可</li>\n</ul>\n<h2>安装方法</h2>\n<pre class=\"prettyprint\"><code>npm install wept -g\n</code></pre><h2>bug &amp; 意见反馈</h2>\n<p>推荐使用 github issues <a href=\"https://github.com/chemzqm/wept/issues\">https://github.com/chemzqm/wept/issues</a>\n或者发送邮件到 <a href=\"mailto:chemzqm@gmail.com\">chemzqm@gmail.com</a></p>\n</div>","title":"「微信小程序」实时运行工具 WEPT 发布 0.3.0","last_reply_at":"2016-11-13T12:38:40.074Z","good":false,"top":false,"reply_count":3,"visit_count":567,"create_at":"2016-10-20T12:19:16.127Z","author":{"loginname":"chemzqm","avatar_url":"https://avatars.githubusercontent.com/u/251450?v=3&s=120"}},{"id":"56894f86c301558265041cdc","author_id":"50b5a3f5637ffa415506deb7","tab":"share","content":"<div class=\"markdown-text\"><p>本文简单介绍在 MacVim 异步进行 node 代码测试，并将测试结果返回到 MacVim quickfix 列表的一种方法。</p>\n<p>这里有段特别不清晰的视频：</p>\n<p><a href=\"http://video.weibo.com/player/1034:02c9053642a0d4b1bf462a0c45b99f42/v.swf\">http://video.weibo.com/player/1034:02c9053642a0d4b1bf462a0c45b99f42/v.swf</a></p>\n<h2>背景介绍</h2>\n<p><a href=\"https://github.com/tpope/vim-dispatch\">vim-dispatch</a> 支持异步执行 shell 命令，但是并不支持 beta 版的 iTerm2, 因为iTerm2 2.9 以后的 applescript 语法完全不同了，然后我就我做了一个简单版本的异步执行插件：<a href=\"https://github.com/chemzqm/vim-iterm2-start\">vim-iterm2-start</a>,  它暂时只支持我现在用的 MacVim, iTerm2  和 fish shell。</p>\n<h2>配合 vim-test</h2>\n<p>配合使用 <a href=\"https://github.com/janko-m/vim-test\">vim-test</a> 我们可以一键异步执行当前鼠标下的测试代码，只需要以下设置：</p>\n<pre class=\"prettyprint language- vim\"><code> nmap &lt;silent&gt; &lt;leader&gt;t :TestNearest&lt;CR&gt;\n function! StartTest(cmd)\n   execute &#x27;ItermStartTab! &#x27; . a:cmd\n endfunction\n let g:test#custom_strategies = {&#x27;start&#x27;: function(&#x27;StartTest&#x27;)}\n let g:test#strategy = &#x27;start&#x27;\n</code></pre><p>使用&lt;leader&gt;t 一键测试</p>\n<p>测试版的 iTerm2  修复了文件路径获取的 bug，你可以直接点击错误信息里的文件路径，通过 profile 里设置 MacVim 为默认编辑器，它可以让你的 MacVim 直接跳转到点击的(⌘+鼠标左键)文件，甚至行号也支持。</p>\n<h2>支援 quickfix</h2>\n<p>接下来我们可以使用一个过滤程序把 mocha 的错误信息发回到 macvim，这样我们就可以直接在 macvim 里面使用 quickfix 列表快速跳转到错误处了，代码实现在这里：<a href=\"https://gist.github.com/chemzqm/fd1313206c182884efbc\">https://gist.github.com/chemzqm/fd1313206c182884efbc</a></p>\n<p>把 error-parse.js 添加可执行权限并连接 path 目录下，我们就可以让它把错误信息通过 MacVim 的 clientserver 特性发回到 MacVim，在 MacVim 下只需要把配置改成：</p>\n<p>execute 'ItermStartTab! ’ . a:cmd . ‘| error-parse.js’</p>\n<p>即可，然后我们就可以愉快的让 iTerm2帮我们执行测试，然后需要看错误的时候 MacVim 下 <code>:copen</code>  打开 quickfix 列表就可以了</p>\n<p>error-parse 的代码实现并不完善，请根据个人喜好进行修改。\n它并不局限与 nodejs ，任何输出错误文件路径的测试工具都可以通过调整它来支持</p>\n</div>","title":"使用 MaVim iTerm2 异步测试 node 代码","last_reply_at":"2016-11-13T12:38:04.027Z","good":false,"top":false,"reply_count":2,"visit_count":656,"create_at":"2016-01-03T16:42:46.904Z","author":{"loginname":"chemzqm","avatar_url":"https://avatars.githubusercontent.com/u/251450?v=3&s=120"}},{"id":"58283e84c1d3b2b57db5e23f","author_id":"5427c0163923ec3b0e6e32db","tab":"ask","content":"<div class=\"markdown-text\"><p>后台一直报这个错：\nError: Can’t set headers after they are sent.\nat ServerResponse.OutgoingMessage.setHeader (_http_outgoing.js:346:11)\nat ServerResponse.header (D:\\WORKING\\WORKSPACE\\MAVEN_PROJECTS\\platform\\Cityb\naoCMS\\node_modules\\express\\lib\\response.js:700:10)\nat ServerResponse.res.contentType.res.type (D:\\WORKING\\WORKSPACE\\MAVEN_PROJE\nCTS\\platform\\CitybaoCMS\\node_modules\\express\\lib\\response.js:537:15)\nat ServerResponse.send (D:\\WORKING\\WORKSPACE\\MAVEN_PROJECTS\\platform\\Citybao\nCMS\\node_modules\\express\\lib\\response.js:129:14)\nat ServerResponse.res.send (D:\\WORKING\\WORKSPACE\\MAVEN_PROJECTS\\platform\\Cit\nybaoCMS\\node_modules\\express-promise\\lib\\express_promise.js:200:13)\nat fn (D:\\WORKING\\WORKSPACE\\MAVEN_PROJECTS\\platform\\CitybaoCMS\\node_modules<br>\nexpress\\lib\\response.js:934:10)\nat View.exports.renderFile [as engine] (D:\\WORKING\\WORKSPACE\\MAVEN_PROJECTS<br>\nplatform\\CitybaoCMS\\node_modules\\ejs\\lib\\ejs.js:355:10)\nat View.render (D:\\WORKING\\WORKSPACE\\MAVEN_PROJECTS\\platform\\CitybaoCMS\\node\n_modules\\express\\lib\\view.js:93:8)\nat EventEmitter.app.render (D:\\WORKING\\WORKSPACE\\MAVEN_PROJECTS\\platform\\Cit\nybaoCMS\\node_modules\\express\\lib\\application.js:566:10)\nat ServerResponse.res.render (D:\\WORKING\\WORKSPACE\\MAVEN_PROJECTS\\platform\\C\nitybaoCMS\\node_modules\\express\\lib\\response.js:938:7)\nat D:\\WORKING\\WORKSPACE\\MAVEN_PROJECTS\\platform\\CitybaoCMS\\node_modules\\expr\ness-partials\\index.js:75:13\nat View.exports.renderFile [as engine] (D:\\WORKING\\WORKSPACE\\MAVEN_PROJECTS<br>\nplatform\\CitybaoCMS\\node_modules\\ejs\\lib\\ejs.js:355:10)\nat View.render (D:\\WORKING\\WORKSPACE\\MAVEN_PROJECTS\\platform\\CitybaoCMS\\node\n_modules\\express\\lib\\view.js:93:8)\nat EventEmitter.app.render (D:\\WORKING\\WORKSPACE\\MAVEN_PROJECTS\\platform\\Cit\nybaoCMS\\node_modules\\express\\lib\\application.js:566:10)\nat ServerResponse.res.render (D:\\WORKING\\WORKSPACE\\MAVEN_PROJECTS\\platform\\C\nitybaoCMS\\node_modules\\express\\lib\\response.js:938:7)\nat ServerResponse.res.render (D:\\WORKING\\WORKSPACE\\MAVEN_PROJECTS\\platform\\C\nitybaoCMS\\node_modules\\express-partials\\index.js:58:9)\n定位不到问题出在哪里，之前还没有问题的，什么都不处理只要请求后台就会报错。\nnodejs调试起来还真实麻烦，各位大神有没有好的办法定位问题</p>\n</div>","title":"找不到原因 Error: Can't set headers after they are sent.","last_reply_at":"2016-11-13T12:26:18.023Z","good":false,"top":false,"reply_count":3,"visit_count":43,"create_at":"2016-11-13T10:20:52.920Z","author":{"loginname":"xhuiinit","avatar_url":"https://avatars.githubusercontent.com/u/4319124?v=2&s=120"}},{"id":"5826e23ec1d3b2b57db5e223","author_id":"528a32b1d2b3893f2a6aceeb","tab":"ask","content":"<div class=\"markdown-text\"><p>感觉node命令行挺好用的，但是一想系统里必须装了node才能跑。啥时候能内置node。</p>\n</div>","title":"Linux 什么时候能内置 Nodejs ？","last_reply_at":"2016-11-13T11:36:31.329Z","good":false,"top":false,"reply_count":4,"visit_count":245,"create_at":"2016-11-12T09:34:54.483Z","author":{"loginname":"Hanggi","avatar_url":"https://avatars.githubusercontent.com/u/5997900?v=3&s=120"}},{"id":"580da170b37ee8fb33978756","author_id":"54009f5ccd66f2eb37190485","tab":"share","content":"<div class=\"markdown-text\"><ul>\n<li>终于出现明白人，我个人认为过度推广就是一种营销，而vue作为一个开源框架，这么做实在让人有些反感，也许不是那么客观。</li>\n<li>你举的这些例子，难道我就没了解吗？当你没了解我是否了解的时候，也请不要妄下结论。不要上过github就像第一次进城一样。</li>\n<li>vue的出现就是对angular 1.x的模仿，无论是模版还是双向绑定。</li>\n</ul>\n<p>ember有个cli可以一键生成项目，vue就出了个vue-cli。</p>\n<p>react出了jsx之后，vue也添加了对jsx的支持，react的vdom号称性能牛逼，vue2.0就也实现了vdom。</p>\n<p>react有reflux、redux实现单项数据流，vue就也实现了个vuex。</p>\n<p>react-native和weex孰先孰后双方各执一词，但是react-native无论是立意还是正式发布都早于weex。</p>\n<p>借鉴本无可厚非，然而其它框架基本没有受到过vue的反哺。</p>\n<p>我说的vue没有理念指的就是vue总是在借鉴、模仿别人，将别人的思想重新实现一遍。</p>\n<p>然后再通过一些技术社交平台来进行推广，就连微信小程序面市，vue2.0都要借势宣传一波，所以js社区才有娱乐圈这种雅称。</p>\n<p>当然这只是我个人的喜好问题，我不喜欢vue，是因为我认为框架最重要的是思想而不是实践。redux的源码也不过几千行，我相信很多人理解redux思想之后，自己实现一个也不是太大的问题，甚至可以比redux实现得更优雅。</p>\n<p>正如rails现在已不如前几年那么&quot;coooool&quot;，可是它的思想可谓被无数web框架借鉴乃至依然显得伟大。</p>\n<p>angular和react/flux也做到了这点，可是vue没有。</p>\n<p>#13楼 <a href=\"/user/hxh1246996371\">@hxh1246996371</a> 另外你要我列举我所谓的场景，不妨我就稍微说说我的看法抛砖引玉</p>\n<p>首先是Angular2引入了ts，可以用作静态类型检查，更方便地写测试代码。引入了模块化，解决了react组件业务切分不明，组件粒度过细导致开发起来常常束手束脚的缺点。有model层可以实现前端管道过滤不规则json，有指令可以实现自治组件，有service可以拆分逻辑代码。Angular2的开发体验更接近后端项目，例如做一个业务极其复杂的企业系统（例如erp、oa等），或者是上千个页面的中大型网站，我很难想象用react或者vue开发如何能够做到多人协作组件复用化还能使项目不杂乱。</p>\n<p>目前和vue使用人群重叠最大的就是react，这二者都是细粒度木偶组件+自由组合智能组件+单向数据流的开发方式，而react当初被提出其实只是fb想要实现一个前端view层的复用，因此数据流动方式其实除了redux这类前端flux思想实现外，还有如relay、graphql以及第三方的meteor等后端框架来让开发者自由使用，此时的开发场景就不仅限于spa页面了。我说的轻重结合，实际上就是指组件拆分细化的话，无论何种场景都可以根据使用情况打包不同的组件来达到快速开发而打包的js文件也不会太大。</p>\n<p>至于weex，一个阿里的kpi项目，用脚趾头想也知道只能选个人项目vue了吧。</p>\n<p>另外riot这类新兴的微型框架就是在这方面做到极致，比如你开发一个只有一个页面的spa，引入一个riot就可以使用各种mvvm特性，打包的js文件还小，这就是我说的微型场景。</p>\n<p>而vue的定位真的很尴尬，高不成低不就。如果你要强行说vue可以开发全部的场景，那也是可以牵强地成立的。不过同时我说jQuery也可以做到，你还要否认的话就是双重标准了。我两年前就用jQuery实现了一个组件化的mvvm框架，虽然那时候刚开始做前端写得不太漂亮。</p>\n</div>","title":"转载一个关于vue的讨论","last_reply_at":"2016-11-13T10:37:32.754Z","good":false,"top":false,"reply_count":97,"visit_count":2902,"create_at":"2016-10-24T05:51:44.199Z","author":{"loginname":"i5ting","avatar_url":"https://avatars.githubusercontent.com/u/3118295?v=3&s=120"}},{"id":"582805de6c4502be6ed87b8f","author_id":"58059a0d487e1e4578afb5ca","tab":"ask","content":"<div class=\"markdown-text\"><p>最近在学习BYVoid大神的开发指南，有两处代码不是很清楚，希望各位大神指教。\n第一处：</p>\n<pre class=\"prettyprint language-javascript\"><code>Post.prototype.save = function save(callback) {\n    &#x2F;&#x2F; 存入 Mongodb 的文档\n    var post = {\n        user: this.user,\n        post: this.post,\n        time: this.time\n    };\n    mongodb.open(function(err, db) {\n        if(err) {\n            return callback(err);\n        }\n        &#x2F;&#x2F; 读取 posts 集合\n        db.collection(&#x27;posts&#x27;, function(err, collection) {\n            if(err) {\n                mongodb.close();\n                return callback(err);\n            }\n            &#x2F;&#x2F; 为 user 属性添加索引\n            collection.ensureIndex(&#x27;user&#x27;);\n            &#x2F;&#x2F; 写入 post 文档\n            collection.insert(post, {safe:true}, function(err, post) {\n                mongodb.close();\n</code></pre><pre class=\"prettyprint\"><code>\t\t   callback(err,post);\n</code></pre><pre class=\"prettyprint language-javascript\"><code>            });\n        });\n    });\n}\n</code></pre><p>调用的callback有两个参数，可是实现Post.prototype.save的callback并没有两个参数，不知道这个callback到底是调用的什么东西？</p>\n<p>第二处：</p>\n<pre class=\"prettyprint language-html\"><code>&lt;% if (user) { %&gt;\n    &lt;%- partial(&#x27;say&#x27;) %&gt;\n&lt;% } %&gt;\n&lt;%- partial(&#x27;posts&#x27;) %&gt;\n</code></pre><p>书上本来说partial这个函数要传两个参数，第一个代表模板，第二个代表对象或数组，可是这里为什么只穿了一个模板名称的参数，在调用时还确实取到了希望取到的posts数据呢。。找了很久没找到partial的文档，希望大神指教</p>\n<p>最后谢谢好心的大神~</p>\n</div>","title":"关于《Node.js开发指南》的两个问题","last_reply_at":"2016-11-13T10:05:43.927Z","good":false,"top":false,"reply_count":5,"visit_count":84,"create_at":"2016-11-13T06:19:10.706Z","author":{"loginname":"StudentWan","avatar_url":"https://avatars.githubusercontent.com/u/19220708?v=3&s=120"}},{"id":"5826f9acd3abab717d8b4be6","author_id":"5809a4c70bab808265185fda","tab":"share","content":"<div class=\"markdown-text\"><h3>Rollup是什么？</h3>\n<p>Rollup是下一代的ES6 JS文件打包工具。和Webpack相似，Rollup支持扩展插件开发，能把模块化的多个JS文件打包成一个文件，还能打包CSS文件（这个功能我还一直没有尝试过）。但是，经常被Rich Harris拿出来炫耀的是Rollup的tree-shaking的能力。即，在打包过程中，Rollup能够自动过滤与剔除没有用到的JS代码和没有调用过的JS函数。\nRollup打包的底层逻辑是“内联”处理被import的ES6模块代码。我理解Rollup是把ES6模块当作是JAVA里的Inline Function来处理的。对于模块动态加载，或许Rollup打包器不能直接满足这个需求。而需要另一个ES6 API：System.import(…)。</p>\n<h3>Rollup-WebWorker打包插件 的 需求由来</h3>\n<p>Rollup自身强悍，也有丰富的第三方插件。<a href=\"https://github.com/rollup/rollup/wiki/Plugins\">请见</a>。但是，这个活跃的生态系统似乎遗漏了我正在遇到的需求类型。简单地概括：\n<strong>打包</strong>  运行在Web Worker里的，依赖传统JS库的，遵循ES6 Moulde规范的 JavaScript程序文件 <strong>成为</strong> 一个IIFE文件。\n我的需求包括以下几个关键点：</p>\n<ol>\n<li>“运行在Web Worker里”意为着 Rollup基于external和globals配置参数的映射机制 对 我的需求 无效。\n<ol>\n<li>简单地说，Rollup的external和globals配置参数 被设计用来 把‘ES6 Import指令’先映射到 HTML &lt;script&gt;标签，再映射到 被引用JS文件构建的全局变量 上。\n<ul>\n<li>比如，把 import io from ‘socket.io-client’; 指令 先映射到 &lt;script src=\"socket.io-client.js\"&gt;标签，再映射到 全局变量io。</li>\n</ul>\n</li>\n<li>但是，这一切对Web Worker是无效的。因为在Web Worker里不能定义&lt;script&gt;标签，所以仅能使用importScripts(…)函数在程序内手动导入依赖库。</li>\n<li>于是，挑战1出现了。</li>\n</ol>\n</li>\n<li>“依赖传统JS库”意为着 被依赖的JS文件 很有可能不是 CMD，AMD，UMD或ES 6模块文件。相反，所谓的传统JS库文件通常是被包装成为一个IIFE表达式（即，一个立即执行的大闭包），并且输出一个全局变量 作为 暴露API集的顶层命名空间。\n<ul>\n<li>但是，挑战2并没有出现，因为‘Rollup的external和globals配置参数’就是被用来解决这个需求的。只不过，正如#1里已经提到的，‘Rollup的external和globals配置参数’要求你的JS文件运行在网页里，而不是运行在Web Worker里。</li>\n</ul>\n</li>\n<li>“遵循ES6 Moulde规范”这需求最容易解决。只要在Rollup的插件链条的最后加上一个Rollup Babel Plugin就行了。</li>\n<li>“输出一个IIFE文件”这需求也简单。只需设置Rollup的打包输出格式参数“format”为“iief”即可。</li>\n</ol>\n<h3>Rollup-WebWorker打包插件 的 设计目标</h3>\n<p>至此，通过总结我的需求，新的Rollup插件需要完成如下几个工作步骤：</p>\n<ol>\n<li>映射 一条ES 6 Module Import 指令 到 一个或多个 JS文件。\n<ul>\n<li>比如，映射 import Zlib from ‘zlib’;  到 两个JS文件 ‘js/lib/gzip.min.js’和’js/lib/gunzip.min.js’。</li>\n</ul>\n</li>\n<li>生成一条importScripts(…)函数调用语句。\n<ul>\n<li>比如，importScripts(‘js/lib/gzip.min.js’, ‘js/lib/gunzip.min.js’);</li>\n</ul>\n</li>\n<li>插入 第2步生成的importScripts(…)语句 到 打包结果文件的顶部第一句的位置。特别提示：importScripts(…)语句一定要被插入在IIFE闭包表达之前，而绝对不能在IIFE的闭包函数体内。</li>\n</ol>\n<h3>Rollup-WebWorker打包插件 的 设计详细</h3>\n<ol>\n<li>实现Rollup Plugin的resolveId(importeeimportee, importer){…}成员函数。\n<ol>\n<li>捕获哪些 传统JS库 正在 ES6代码中 被依赖。即，知道import指令中from关键字后面的依赖模块名。 比如，从ES6指令import Zlib from ‘zlib’;抽取模块名’zlib’。</li>\n<li>翻译 被捕获的依赖模块名 为 具体的一个或多个JS文件路径。即，通过 预传入的“模块名－文件名 映射表”，把’zlib’映射成 'js/lib/gzip.min.js’和’js/lib/gunzip.min.js’两个文件路径。</li>\n<li>生成importScripts(…)函数调用语句。比如，importScripts(‘js/lib/gzip.min.js’, ‘js/lib/gunzip.min.js’);</li>\n</ol>\n</li>\n<li>实现Rollup Plugin的banner(){…}成员函数。\n<ol>\n<li>把 被生成的importScripts(…)语句 直接作为banner(){…}函数的返回字符串return出去即可。</li>\n<li>最终，importScripts(…)语句就会出现在 打包结果文件的顶行第一句的位置。</li>\n</ol>\n</li>\n</ol>\n<h3>Rollup-WebWorker打包插件 带来的改善</h3>\n<p>给Rollup写插件是不是so easy。更重要的是，仅只需要投入大约40到60分钟就能够立杆见影地解决工程构建过程中出现的棘手问题。仅这一点点的改善就确保了“网页JS编程”与“Web Worker开发”的一致编码风格与开发体验。即，\n在ES6代码里，透明化对传统JS依赖的导入操作。\n1. 无论依赖模块是AMD，CMD，UMD，ES6 Module，还是传统的IIFE闭包，\n2. 无论JS程序是运行在网页渲染主线程，还是运行在Web Worker线程里，\nES6 Module的Import指令都能够将它们导入你当前的运行环境上下文。</p>\n<h3>Rollup-WebWorker打包插件 源码</h3>\n<pre class=\"prettyprint language-js\"><code>var _ = require(&#x27;underscore&#x27;), path = require(&#x27;path&#x27;);\nmodule.exports = function(options){\n  var pluginName = &#x27;Web Worker&#x27;, optExternal, optPaths, importScripts = [], history = [], dirTopFilepath, relTopFilepath, topFilepath;\n  return {\n    &#x27;name&#x27;: pluginName,\n    &#x27;options&#x27;: function(options){ &#x2F;&#x2F; 从Rollup的配置中抽取external与paths配置参数。external与paths都是Rollup的标准配置项。\n      optExternal = options.external || []; &#x2F;&#x2F; 用法与语义都等同于Rollup对external参数的默认配置定义。\n      optPaths = options.paths || {}; &#x2F;&#x2F; 用法与语义都等同于Rollup对paths参数的默认配置定义。\n      delete options.external;\n      delete options.paths;\n    },\n    &#x27;resolveId&#x27;: function(importee, importer){\n      if (!importer) {\n        topFilepath = importee; &#x2F;&#x2F; 获得ES 6代码编译的入口文件的文件名\n        relTopFilepath = path.relative(options.cwd, topFilepath);\n        dirTopFilepath = path.dirname(relTopFilepath);\n      }\n      if (optExternal.indexOf(importee) &lt; 0) {\n        return null; &#x2F;&#x2F; 将控件权移交给Rollup插件链条中的下一个Rollup插件实例。\n      }\n      if (history.indexOf(importee) &gt; -1) {\n        return false; &#x2F;&#x2F; 此依赖已经处理过了，不再重复处理，在此处跳过。\n      }\n      var pathImportees = optPaths[importee];\n      if (pathImportees) {\n        if (!_.isArray(pathImportees)) {\n          pathImportees = [pathImportees];\n        }\n        pathImportees.forEach(function(pathImportee){\n          var refImportee = path.relative(dirTopFilepath, pathImportee);\n          importScripts.push(refImportee); &#x2F;&#x2F; 在此处，收集传统JS依赖库的文件名。\n        });\n      }\n      history.push(importee);\n      return false; \n    },\n    &#x27;banner&#x27;: function(){\n      var polyfills = options.polyfills;\n      if (!_.isArray(polyfills)) {\n        polyfills = [polyfills];\n      }\n      polyfills.reverse().forEach(function(polyfill){\n        var refImportee = path.relative(dirTopFilepath, polyfill);\n        importScripts.unshift(refImportee);\n      });\n      return &quot;importScripts(&#x27;&quot; + importScripts.join(&quot;&#x27;, &#x27;&quot;).replace(&#x2F;\\\\&#x2F;g, &#x27;&#x2F;&#x27;) + &quot;&#x27;);&quot;; &#x2F;&#x2F; 生成importScripts(...)调用语句，并输出到 打包结果文件的 顶行第一句的位置。\n    }\n  };\n};\n</code></pre><h3>Rollup-WebWorker打包插件 的使用</h3>\n<p>在这里，以Grunt为例。</p>\n<pre class=\"prettyprint language-js\"><code>var Babel = require(&#x27;rollup-plugin-babel&#x27;), WebWorker = require(&#x27;.&#x2F;src&#x2F;js&#x2F;lib&#x2F;rollup-plugin-webworker&#x27;);\ngrunt.config.merge({\n  &#x27;rollup&#x27;: {\n    &#x27;worker&#x27;: {\n      &#x27;options&#x27;: {\n        &#x27;external&#x27;: [&#x27;underscore&#x27;, &#x27;socket.io&#x27;, &#x27;zlib&#x27;], &#x2F;&#x2F; 注册外部依赖的模块名称\n        &#x27;globals&#x27;: { &#x2F;&#x2F; 注册 外部依赖的 模块名称 至 全局变量名 的映射关系表\n          &#x27;underscore&#x27;: &#x27;_&#x27;,\n          &#x27;zlib&#x27;: &#x27;Zlib&#x27;,\n          &#x27;socket.io&#x27;: &#x27;io&#x27;\n        },\n        &#x27;paths&#x27;: { &#x2F;&#x2F; 注册 外部依赖的 模块名称 至 文件路径 的映射关系表\n          &#x27;underscore&#x27;: &#x27;js&#x2F;lib&#x2F;underscore.js&#x27;, \n          &#x27;zlib&#x27;: [&#x27;js&#x2F;lib&#x2F;gzip.min.js&#x27;, &#x27;js&#x2F;lib&#x2F;gunzip.min.js&#x27;],\n          &#x27;socket.io&#x27;: &#x27;js&#x2F;lib&#x2F;socket.io-1.5.1.js&#x27;\n        },\n        &#x27;plugins&#x27;: [WebWorker({ &#x2F;&#x2F; 启用Rollup WebWorker打包插件 \n          &#x27;cwd&#x27;: &#x27;src&#x27;,\n          &#x27;polyfills&#x27;: [&#x27;js&#x2F;lib&#x2F;web-worker-runtime.js&#x27;, &#x27;js&#x2F;lib&#x2F;polyfill.js&#x27;]\n        }), Babel()]\n      },\n      &#x27;files&#x27;: [{\n        &#x27;cwd&#x27;: &#x27;src&#x27;,\n        &#x27;expand&#x27;: true,\n        &#x27;dest&#x27;: &#x27;.build&#x27;,\n        &#x27;src&#x27;: [&#x27;js&#x2F;workers&#x2F;*.js&#x27;]\n      }]\n    }\n  }\n});\n</code></pre><h3>后面的计划</h3>\n<p>我正在学习如何在Github上创建工程，我想把这个rollup-webworker-plugin贡献到Rollup的第三方插件集中。</p>\n</div>","title":"自制Rollup-WebWorker打包插件","last_reply_at":"2016-11-13T08:52:10.261Z","good":false,"top":false,"reply_count":4,"visit_count":135,"create_at":"2016-11-12T11:14:52.083Z","author":{"loginname":"stuartZhang","avatar_url":"https://avatars.githubusercontent.com/u/13935927?v=3&s=120"}},{"id":"582632246c4502be6ed87b5a","author_id":"54eec259b266136b3949b1e0","tab":"ask","content":"<div class=\"markdown-text\"><p>做爬虫需要大量ip代理服务器，该从哪里买？</p>\n</div>","title":"做爬虫需要大量ip","last_reply_at":"2016-11-13T07:47:38.370Z","good":false,"top":false,"reply_count":6,"visit_count":216,"create_at":"2016-11-11T21:03:32.056Z","author":{"loginname":"klausgao","avatar_url":"https://avatars.githubusercontent.com/u/11207273?v=3&s=120"}},{"id":"58244440b71596cc38678453","author_id":"56764926cd926feb0c0c8f4e","tab":"share","content":"<div class=\"markdown-text\"><p>Online demo:<a href=\"http://yangxiaofu.com/deep-in-vue/src/the-super-tiny-vue.html\">http://yangxiaofu.com/deep-in-vue/src/the-super-tiny-vue.html</a>\ngithub: <a href=\"https://github.com/xiaofuzi/deep-in-vue/blob/master/src/the-super-tiny-vue.js\">https://github.com/xiaofuzi/deep-in-vue/blob/master/src/the-super-tiny-vue.js</a>\nes6版本：<a href=\"https://github.com/xiaofuzi/re-vue\">https://github.com/xiaofuzi/re-vue</a>\n/**</p>\n<ul>\n<li>the super tiny vue.js.</li>\n<li>代码总共200行左右(去掉注释)\n*/\n简介：一个迷你vue库，虽然小但功能全面，可以作为想了解vue背后思想以及想学习vue源码而又不知如何入手的入门学习资料。</li>\n</ul>\n<p>特性：</p>\n<ul>\n<li>数据响应式更新</li>\n<li>指令模板</li>\n<li>MVVM</li>\n<li>轻量级</li>\n</ul>\n<h2>功能解读</h2>\n<pre class=\"prettyprint language-html\"><code> &lt;templete&gt;\n    &lt;div id=&#x27;app&#x27;&gt;\n        &lt;div&gt;\n            &lt;input v-model=&#x27;counter&#x27; &#x2F;&gt;\n            &lt;button v-on-click=&#x27;add&#x27;&gt;add&lt;&#x2F;button&gt;\n            &lt;p v-text=&#x27;counter&#x27;&gt;&lt;&#x2F;p&gt;\n        &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n &lt;&#x2F;templete&gt;\n</code></pre><pre class=\"prettyprint language-js\"><code>var vm = new Vue({\n        id: &#x27;counter&#x27;,\n        data: {\n            counter: 1\n        },\n        methods: {\n            add: function () {\n                this.counter += 1;\n            }\n        }\n    })\n</code></pre><p>如上为一段模板以及js脚本，我们所要实现的目标就是将 vm 实例与id为app的DOM节点关联起来，当更改vm data 的counter属性的时候，\ninput的值和p标签的文本会响应式的改变，method中的add方法则和button的click事件绑定。\n简单的说就是, 当点击button按钮的时候，触发button的点击事件回调函数add,在add方法中使counter加1，counter变化后模板中的input\n和p标签会自动更新。vm与模板之间是如何关联的则是通过 v-model、v-on-click、v-text这样的指令声明的。</p>\n<h3>实现思路详解</h3>\n<ul>\n<li>查找含指令的节点</li>\n<li>对查找所得的节点进行指令解析、指令所对应的实现与节点绑定、 节点指令值所对应的data属性与前一步关联的指令实现绑定、data属性值通过setter通知关联的指令进行更新操作</li>\n<li>含指令的每一个节点单独执行第二步</li>\n<li>绑定操作完成后，初始化vm实例属性值</li>\n</ul>\n<h4>指令节点查找</h4>\n<p>首先来看第一步，含指令节点的查找，因为指令声明是以属性的形式，所以可以通过属性选择器来进行查找，如下所示：</p>\n<p><code>&lt;input v-model='counter' type='text' /&gt;</code>\n则可通过 querySelectorAll(’[v-model]’) 查找即可。</p>\n<pre class=\"prettyprint language-js\"><code>  root = this.$el = document.getElementById(opts.el),\n  els  = this.$els = root.querySelectorAll(getDirSelectors(Directives))\n</code></pre><p>root对于根节点，els对应于模板内含指令的节点。</p>\n<h4>指令解析，绑定</h4>\n<ul>\n<li>1.指令解析\n同样以<code>&lt;input v-model='counter' type='text' /&gt;</code>为例，解析即得到</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>var directive = {\n   name: &#x27;v-model&#x27;,\n   value: &#x27;counter&#x27;\n}\n</code></pre><p>name对应指令名，value对应指令值。</p>\n<ul>\n<li>2.指令对应实现与当前节点的绑定(bindDirective)\n指令实现可简单分为函数或是包含update函数的对象，如下便是<code>v-text</code>指令的实现代码：</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>text: function (el, value) {\n       el.textContent = value || &#x27;&#x27;;\n   }\n</code></pre><p>指令与节点的绑定即将该函数与节点绑定起来，即该函数负责该节点的更新操作，<code>v-text</code>的功能是更新文本值，所以如上所示\n更改节点的textContent属性值。</p>\n<ul>\n<li>\n<ol>\n<li>响应式数据与节点的绑定(bindAccessors)\n响应式数据这里拆分为 data 和 methods 对象，分别用来存储数据值和方法。</li>\n</ol>\n<pre class=\"prettyprint language-js\"><code>var vm = new Vue({\n    id: &#x27;counter&#x27;,\n    data: {\n        counter: 1\n    },\n    methods: {\n        add: function () {\n            this.counter += 1;\n        }\n    }\n})\n</code></pre>我们上面解析得到 v-model 对于的指令值为 counter,所以这里将data中的counter与当前节点绑定。</li>\n</ul>\n<p>通过2、3两步实现了类型与 textDirective-&gt;el&lt;-data.counter 的关联，当data.counter发生set(具体查看defineProperty set 用法)操作时，\ndata.counter得知自己被改变了，所以通知el元素需要进行更新操作，el则使用与其关联的指令(textDirective)对自身进行更新操作，从而实现了数据的\n响应式。</p>\n<pre class=\"prettyprint\"><code>* textDirective\n* el\n* data.counter\n</code></pre><p>这三个是绑定的主体，数据发生更改，通知节点需要更新，节点通过指令更新自己。</p>\n<ul>\n<li>4.其它相关操作</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>var prefix = &#x27;v&#x27;;\n &#x2F;**\n  * Directives\n  *&#x2F;\n\nvar Directives = {\n    &#x2F;**\n     * 对应于 v-text 指令\n     *&#x2F;\n    text: function (el, value) {\n        el.textContent = value || &#x27;&#x27;;\n    },\n    &#x2F;**\n     * 对应于 v-model 指令\n     *&#x2F;\n    model: function (el, value, dirAgr, dir, vm, key) {\n        let eventName = &#x27;keyup&#x27;;\n        el.value = value || &#x27;&#x27;;\n\n        &#x2F;**\n         * 事件绑定控制\n         *&#x2F;\n        if (el.handlers &amp;&amp; el.handlers[eventName]) {\n            el.removeEventListener(eventName, el.handlers[eventName]);\n        } else {\n            el.handlers = {};\n        }\n\n        el.handlers[eventName] = function (e) {\n            vm[key] = e.target.value;\n        }\n\n        el.addEventListener(eventName, el.handlers[eventName]);\n    },\n    on: {\n        update: function (el, handler, eventName, directive) {\n            if (!directive.handlers) {\n                directive.handlers = {}\n            }\n\n            var handlers = directive.handlers;\n\n            if (handlers[eventName]) {\n                &#x2F;&#x2F;绑定新的事件前移除原绑定的事件函数\n                el.removeEventListener(eventName, handlers[eventName]);\n            }\n            &#x2F;&#x2F;绑定新的事件函数\n            if (handler) {\n                handler = handler.bind(el);\n                el.addEventListener(eventName, handler);\n                handlers[eventName] = handler;\n            }\n        }\n    }\n}\n\n\n&#x2F;**\n * MiniVue \n *&#x2F;\nfunction TinyVue (opts) {\n    &#x2F;**\n     * root&#x2F;this.$el: 根节点\n     * els: 指令节点\n     * bindings: 指令与data关联的桥梁\n     *&#x2F;\n    var self = this,\n        root = this.$el = document.getElementById(opts.el),\n        els  = this.$els = root.querySelectorAll(getDirSelectors(Directives)),\n        bindings = {};\n\n    &#x2F;**\n     * 指令处理\n     *&#x2F;\n    [].forEach.call(els, processNode);\n    processNode(root);\n\n    &#x2F;**\n     * vm响应式数据初始化\n     *&#x2F;\n\n    let _data = extend(opts.data, opts.methods);\n    for (var key in bindings) {\n        if (bindings.hasOwnProperty(key)) {\n            self[key] = _data[key];\n        }\n    }\n\t&#x2F;**\n     * ready methods\n     *&#x2F;\n    if (opts.ready &amp;&amp; typeof opts.ready == &#x27;function&#x27;) {\n        this.ready = opts.ready;\n        this.ready();\n    }\n\t\n    function processNode (el) {\n        getAttributes(el.attributes).forEach(function (attr) {\n            var directive = parseDirective(attr);\n            if (directive) {\n                bindDirective(self, el, bindings, directive);\n            }\n        })\n    }\n}\n\n&#x2F;**************************************************************\n * @privete\n * helper methods\n *&#x2F;\n\n&#x2F;**\n * 获取节点属性\n * &#x27;v-text&#x27;=&#x27;counter&#x27; =&gt; {name: v-text, value: &#x27;counter&#x27;}\n *&#x2F;\nfunction getAttributes (attributes) {\n    return [].map.call(attributes, function (attr) {\n        return {\n            name: attr.name,\n            value: attr.value\n        }\n    })\n}\n\n&#x2F;**\n * 返回指令选择器，便于指令节点的查找\n *&#x2F;\nfunction getDirSelectors (directives) {\n    &#x2F;**\n     * 支持的事件指令\n     *&#x2F;\n    let eventArr = [&#x27;click&#x27;, &#x27;change&#x27;, &#x27;blur&#x27;]; \n\n\n    return Object.keys(directives).map(function (directive) {\n        &#x2F;**\n         * text =&gt; &#x27;v-text&#x27;\n         *&#x2F;\n        return &#x27;[&#x27; + prefix + &#x27;-&#x27; + directive + &#x27;]&#x27;;\n    }).join() + &#x27;,&#x27; + eventArr.map(function (eventName) {\n        return &#x27;[&#x27; + prefix + &#x27;-on-&#x27; + eventName + &#x27;]&#x27;;\n    }).join();\n}\n\n&#x2F;**\n * 节点指令绑定\n *&#x2F;\nfunction bindDirective (vm, el, bindings, directive) {\n    &#x2F;&#x2F;从节点属性中移除指令声明\n    el.removeAttribute(directive.attr.value);\n    \n    &#x2F;**\n     * v-text=&#x27;counter&#x27;\n     * v-model=&#x27;counter&#x27;\n     * data = { \n            counter: 1 \n        } \n     * 这里的 counter 即指令的 key\n     *&#x2F;\n    var key = directive.key,\n        binding = bindings[key];\n\n    if (!binding) {\n        &#x2F;**\n         * value 即 counter 对应的值\n         * directives 即 key 所绑定的相关指令\n         如：\n           bindings[&#x27;counter&#x27;] = {\n                value: 1,\n                directives: [textDirective, modelDirective]\n             }\n         *&#x2F;\n        bindings[key] = binding = {\n            value: &#x27;&#x27;,\n            directives: []\n        }\n    }\n    directive.el = el;\n    binding.directives.push(directive);\n\n    &#x2F;&#x2F;避免重复定义\n    if (!vm.hasOwnProperty(key)) {\n        &#x2F;**\n         * get&#x2F;set 操作绑定\n         *&#x2F;\n        bindAccessors(vm, key, binding);\n    }\n}\n\n&#x2F;**\n * get&#x2F;set 绑定指令更新操作\n *&#x2F;\nfunction bindAccessors (vm, key, binding) {\n    Object.defineProperty(vm, key, {\n        get: function () {\n            return binding.value;\n        },\n        set: function (value) {\n            binding.value = value;\n            binding.directives.forEach(function (directive) {\n                directive.update(\n                    directive.el,\n                    value,\n                    directive.argument,\n                    directive,\n                    vm,\n                    key\n                )\n            })\n        }\n    })\n}\n\nfunction parseDirective (attr) {\n    if (attr.name.indexOf(prefix) === -1) return ;\n\n    &#x2F;**\n     * 指令解析\n       v-on-click=&#x27;onClick&#x27;\n       这里的指令名称为 &#x27;on&#x27;, &#x27;click&#x27;为指令的参数，onClick 为key\n     *&#x2F;\n\n    &#x2F;&#x2F;移除 &#x27;v-&#x27; 前缀, 提取指令名称、指令参数\n    var directiveStr = attr.name.slice(prefix.length + 1),\n        argIndex = directiveStr.indexOf(&#x27;-&#x27;),\n        directiveName = argIndex === -1\n            ? directiveStr\n            : directiveStr.slice(0, argIndex),\n        directiveDef = Directives[directiveName],\n        arg = argIndex === -1\n            ? null\n            : directiveStr.slice(argIndex + 1);\n\n    &#x2F;**\n     * 指令表达式解析，即 v-text=&#x27;counter&#x27; counter的解析\n     * 这里暂时只考虑包含key的情况\n     *&#x2F;\n    var key = attr.value;\n    return directiveDef\n        ? {\n            attr: attr,\n            key: key,\n            dirname: directiveName,\n            definition: directiveDef,\n            argument: arg,\n            &#x2F;**\n             * 指令本身是一个函数的情况下，更新函数即它本身，否则调用它的update方法\n             *&#x2F;\n            update: typeof directiveDef === &#x27;function&#x27;\n                ? directiveDef\n                : directiveDef.update\n        }\n        : null;\n}\n\n&#x2F;**\n * 对象合并\n *&#x2F;\nfunction extend (child, parent) {\n    parent = parent || {};\n    child = child || {};\n    for(var key in parent) {\n        if (parent.hasOwnProperty(key)) {\n            child[key] = parent[key];\n        }\n    }\n    return child;\n}\n</code></pre></div>","title":"the super tiny vue.js(添加es6版本)","last_reply_at":"2016-11-13T06:27:35.271Z","good":false,"top":false,"reply_count":8,"visit_count":273,"create_at":"2016-11-10T09:56:16.542Z","author":{"loginname":"xiaofuzi","avatar_url":"https://avatars.githubusercontent.com/u/4171913?v=3&s=120"}},{"id":"582561cf1120be9438b02ad2","author_id":"5747b012fd93c1011f94ab88","tab":"share","content":"<div class=\"markdown-text\"><p>未实现功能：</p>\n<ul>\n<li>发布话题（11-12已实现）</li>\n<li>回复话题（11-12已实现）</li>\n</ul>\n<p>gif预览：\n<img src=\"//dn-cnode.qbox.me/FsyLTXOZR-ogb38NhxypJ9njH8hG\" alt=\"test1.gif\"></p>\n<p>线上访问： <a href=\"http://jjboom.net/cnode\">cnode</a></p>\n<p><img src=\"//dn-cnode.qbox.me/FkX5KD5dhEbJ-0MC3NKeeAs9MQf8\" alt=\"4~IY%609HZ{LH7W`G~OR%WV.png\"></p>\n</div>","title":"用了antd-mobile写了一个cnode社区","last_reply_at":"2016-11-13T06:04:52.970Z","good":false,"top":false,"reply_count":14,"visit_count":191,"create_at":"2016-11-11T06:14:39.388Z","author":{"loginname":"dianjie","avatar_url":"https://avatars.githubusercontent.com/u/16601627?v=3&s=120"}},{"id":"5825c2041120be9438b02af8","author_id":"54b0f146ce87bace2444ceca","tab":"ask","content":"<div class=\"markdown-text\"><p>有一个需求就是不停从redis里面取数据。我想的就是使用async.dowhilst做循环操作。但是这个操作并不能很好的体现node的异步特性。。async.dowhilst相当于把异步变同步。不知道大神们是怎么用循环来处理异步的。</p>\n<p>来自酷炫的 <a href=\"https://github.com/TakWolf/CNode-Material-Design\">CNodeMD</a></p>\n</div>","title":"node循环处理异步操作除了通过流程控制以及递归之外还有没有其他的方式。","last_reply_at":"2016-11-13T05:28:21.225Z","good":false,"top":false,"reply_count":5,"visit_count":124,"create_at":"2016-11-11T13:05:08.529Z","author":{"loginname":"weierbufan","avatar_url":"https://avatars.githubusercontent.com/u/6757408?v=3&s=120"}},{"id":"5827eba0c1d3b2b57db5e235","author_id":"559f6bb9419f1e8a23a64163","tab":"ask","content":"<div class=\"markdown-text\"><p>在使用mongoose进行aggregate 对某个进行$sum前，如何将原有的string转化为number类型？</p>\n</div>","title":"在使用mongoose进行aggregate 对某个进行$sum前，如何将原有的string转化为number类型？","last_reply_at":"2016-11-13T04:27:12.537Z","good":false,"top":false,"reply_count":0,"visit_count":38,"create_at":"2016-11-13T04:27:12.537Z","author":{"loginname":"qimuyunduan","avatar_url":"https://avatars.githubusercontent.com/u/3916574?v=3&s=120"}},{"id":"58271691e885ce5a39382847","author_id":"56764926cd926feb0c0c8f4e","tab":"ask","content":"<div class=\"markdown-text\"><p>cnode评论的排序为什么要设计成按发布的先后顺序排序而不是最新的评论靠前？</p>\n<p>虽说从前往后看比较符合人类的阅读习惯，但每次要看最新的评论都得费不少时间（评论多了也做不了分页）。</p>\n</div>","title":"cnode评论的排序为什么要设计成按时间顺序排序而不是最新的评论靠前？（求作者解答）","last_reply_at":"2016-11-13T03:40:09.988Z","good":false,"top":false,"reply_count":3,"visit_count":103,"create_at":"2016-11-12T13:18:09.114Z","author":{"loginname":"xiaofuzi","avatar_url":"https://avatars.githubusercontent.com/u/4171913?v=3&s=120"}},{"id":"58217f96be0a73ad054895be","author_id":"558a0ac301d3ce0d73d69179","tab":"job","content":"<div class=\"markdown-text\"><p>简历投递地址：<a href=\"https://www.lagou.com/jobs/2550677.html\">https://www.lagou.com/jobs/2550677.html</a></p>\n<p><strong>职位描述</strong></p>\n<p>加入我们，一起创新</p>\n<hr>\n<p>在云和互动，工程师主导着技术和项目</p>\n<p>我们会用Node.js、Lua来实现我们的核心系统</p>\n<p>我们会用Lua/C来开发极致性能</p>\n<p>我们会用灵活的Node.js作为接口层粘合剂</p>\n<p>我们会用简洁NoSQL数据库以及ElasticSearch做数据分析</p>\n<p>我们会用酷炫的AngularJS/Vuejs/React来展现Web</p>\n<p>我们只用正确的技术解决实际问题。</p>\n<p><strong>我们只对有丰富经验的优秀工程师提供这个职位，我们希望您：</strong></p>\n<hr>\n<p>拥有丰富的互联网产品研发项目经验</p>\n<p>具备系统设计和分解任务的能力，并能胜任code review的工作;</p>\n<p>至少精通Node.js、PHP、JAVA、Lua语言中的一种；</p>\n<p>针对性能、安全、高可用、并发等技术主题能有比较深刻的理解；</p>\n<p>对我们的技术栈Node.js + Lua + ElasticSearch有强烈的兴趣（重要）</p>\n<p><strong>我们能提供：</strong></p>\n<hr>\n<p>做你自己喜欢并相信的事情，用技术解决实际的问题</p>\n<p>持续的共同学习和分享机制，团队全栈研发</p>\n<p>标配的五险一金和有竞争力的薪水，持续的期权机制；</p>\n<p>工作地点北京</p>\n<p>可自带装备享受补贴，也可公司配给Macbook Pro + 专业显示器</p>\n<p>带薪年假，自由调休</p>\n<p>弹性工作时间</p>\n<p>定期团建活动</p>\n<p>简历投递地址：<a href=\"https://www.lagou.com/jobs/2550677.html\">https://www.lagou.com/jobs/2550677.html</a></p>\n</div>","title":"[北京][魏公村]【12~20K】诚聘Node.js工程师，加入我们，一起创新><","last_reply_at":"2016-11-13T02:42:23.935Z","good":false,"top":false,"reply_count":2,"visit_count":138,"create_at":"2016-11-08T07:32:38.849Z","author":{"loginname":"richenlin","avatar_url":"https://avatars.githubusercontent.com/u/6151439?v=3&s=120"}},{"id":"581bf651d5e70f9005343333","author_id":"564c6c451ba2ef107f854db2","tab":"ask","content":"<div class=\"markdown-text\"><p>最近在用loopback，遇到一些问题，看了文档和相关的代码，有些疑惑问题，求解答。主要是控制方面的问题，看了范例的 loopback-example-access-control-master代码\n1、关于role的，有个Role.registerResolver 的用法，似乎看起来是在执行中，如果Acl里面说明的principalId 定义过Role，则匹配在这里进行执行，如果返回（null, false) 则拒绝访问。作用是否就是产生临时的Role成员啊？请明确一下，如果该用户定义过role ，是否也要跳转到这里进行执行，我想应该是忽略这个处理的，不太肯定，因为范例上面这里没有写区分，请帮忙确认一下。\n2、关于relations，这个应该是loopback的核心了，感觉relations 关联后，可以继承相关的方法，相当于链接了函数过程，看范例代码，似乎可以这样么做的。最主要是看了代码里面的foreignKey 有疑惑，比如A和B之间的relations A&amp;B，和 A和C之间的relations A&amp;C， foreignKey 的key只存在于C 的properties 内容之中，但是A&amp;B 和A&amp;C都用这个key作为foreignKey，这样做也可以么？难道关系可以变成 B -&gt;A -&gt;C 的关系么，虽然A和B的properties都没有这个key,但是可以通过C获得这个key作为foreignKey，这样做也可以么？这个和relations 的type 有关系么？请解惑。\n3、文档内的Partitioning users with realms 章节只有寥寥几笔，难道仅仅是给user强制增加一个realms的？是否有其他隐含的意思，看文档说的不明确。。似乎可以定于区域，但是一笔带过。。\nLoopback 是个不错的框架，仅看看代码就知道挺好的，就是文档看起来比较多，其实相对于它的功能而言还是不足，还是很多遗漏的东西，害的我还以为没有这个功能呢，最后自己测出来是有的，apidoc里面还写的简单的很，全靠看代码啊。。。。\n请大神帮忙，赐教，谢谢。</p>\n</div>","title":"Loopback 的问题，请高手帮忙看看，解答一下","last_reply_at":"2016-11-12T18:09:26.680Z","good":false,"top":false,"reply_count":4,"visit_count":276,"create_at":"2016-11-04T02:45:37.345Z","author":{"loginname":"cnlile","avatar_url":"https://avatars.githubusercontent.com/u/14039380?v=3&s=120"}},{"id":"58252a041120be9438b02ab1","author_id":"5788820569d72f545483cc03","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"https://1111.segmentfault.com/\">光棍节程序员闯关秀</a>\n大家快来试试能闯到第几关</p>\n</div>","title":"光棍节程序员闯关","last_reply_at":"2016-11-12T14:55:06.771Z","good":false,"top":false,"reply_count":6,"visit_count":453,"create_at":"2016-11-11T02:16:36.507Z","author":{"loginname":"backcj","avatar_url":"https://avatars.githubusercontent.com/u/12507888?v=3&s=120"}},{"id":"58255a6be885ce5a39382800","author_id":"56daaf5dc0fa23473d005feb","tab":"ask","content":"<div class=\"markdown-text\"><p>如题，请各位大牛指教一下😄</p>\n</div>","title":"连接MySQL数据库除了mysql模块之外还有哪个模块比较好呢","last_reply_at":"2016-11-12T13:05:23.261Z","good":false,"top":false,"reply_count":6,"visit_count":177,"create_at":"2016-11-11T05:43:07.051Z","author":{"loginname":"zhulinwei","avatar_url":"https://avatars.githubusercontent.com/u/17670262?v=3&s=120"}},{"id":"57f5cd82d547294d6a47081e","author_id":"57bfb35b100afbbc0dcc53c4","tab":"share","content":"<div class=\"markdown-text\"><p>用到的技术都比较基础, jQuery什么的。\n###运行截图</p>\n<ol>\n<li>登录\n<img src=\"https://github.com/P-ppc/cnodejs/raw/master/imgPreview/login@2x.png\" alt=\"image\"></li>\n<li>主页\n<img src=\"https://github.com/P-ppc/cnodejs/raw/master/imgPreview/index@2x.png\" alt=\"image\"></li>\n<li>话题\n<img src=\"https://github.com/P-ppc/cnodejs/raw/master/imgPreview/topicInfo@2x.png\" alt=\"image\"></li>\n<li>消息\n<img src=\"https://github.com/P-ppc/cnodejs/raw/master/imgPreview/message@2x.png\" alt=\"image\"></li>\n<li>收藏\n<img src=\"https://github.com/P-ppc/cnodejs/raw/master/imgPreview/collection@2x.png\" alt=\"image\"></li>\n<li>用户信息\n<img src=\"https://github.com/P-ppc/cnodejs/raw/master/imgPreview/userInfo@2x.png\" alt=\"image\"></li>\n<li>创建话题\n<img src=\"https://github.com/P-ppc/cnodejs/raw/master/imgPreview/createTopic@2x.png\" alt=\"image\">\n<br>\n有很多功能还未实现, 具体见<a href=\"https://github.com/P-ppc/cnodejs\">github</a>。有问题的话欢迎指出。\nNote:<s>目前还没提供windows的下载，但是安装包貌似太大, 超过github的上限，所以还是推荐自己编译安装的方式。</s> 现已提供Mac, windows64位和32位的打包命令</li>\n</ol>\n</div>","title":"新人做了一个cnodejs的桌面客户端，欢迎大家指点","last_reply_at":"2016-11-12T12:24:24.941Z","good":false,"top":false,"reply_count":34,"visit_count":1959,"create_at":"2016-10-06T04:05:22.179Z","author":{"loginname":"P-ppc","avatar_url":"https://avatars.githubusercontent.com/u/13051135?v=3&s=120"}},{"id":"56e01c7a255ed94c6e4c2724","author_id":"5110f2bedf9e9fcc584e4677","tab":"share","content":"<div class=\"markdown-text\"><h2>Mongolass</h2>\n<p><a href=\"https://npmjs.org/package/mongolass\"><img src=\"https://img.shields.io/npm/v/mongolass.svg?style=flat-square\" alt=\"NPM version\"></a>\n<a href=\"https://travis-ci.org/mongolass/mongolass\"><img src=\"https://img.shields.io/travis/mongolass/mongolass.svg?style=flat-square\" alt=\"Build status\"></a>\n<a href=\"https://david-dm.org/mongolass/mongolass\"><img src=\"http://img.shields.io/david/mongolass/mongolass.svg?style=flat-square\" alt=\"Dependency Status\"></a>\n<a href><img src=\"http://img.shields.io/npm/l/mongolass.svg?style=flat-square\" alt=\"License\"></a>\n<a href=\"https://npmjs.org/package/mongolass\"><img src=\"http://img.shields.io/npm/dm/mongolass.svg?style=flat-square\" alt=\"Downloads\"></a></p>\n<p>Elegant MongoDB driver for Node.js.</p>\n<h2>Installation</h2>\n<pre class=\"prettyprint\"><code>$ npm i mongolass --save\n</code></pre><h2>Introduction</h2>\n<p>Just like mongoose:</p>\n<pre class=\"prettyprint\"><code>&#x27;use strict&#x27;;\n\nlet Mongolass = require(&#x27;mongolass&#x27;);\nlet mongolass = new Mongolass();&#x2F;&#x2F; let mongolass = new Mongolass(&#x27;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;test&#x27;);\nmongolass.connect(&#x27;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;test&#x27;);\n\nlet User = mongolass.model(&#x27;User&#x27;);\n\nUser\n  .find()\n  .select({ name: 1, age: 1 })\n  .sort({ name: -1 })\n  .exec()\n  .then(console.log)\n  .catch(console.error);\n</code></pre><p>or use optional schema:</p>\n<pre class=\"prettyprint\"><code>&#x27;use strict&#x27;;\n\nlet Mongolass = require(&#x27;mongolass&#x27;);\nlet Schema = Mongolass.Schema;\nlet mongolass = new Mongolass();\nmongolass.connect(&#x27;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;test&#x27;);\n\nlet UserSchema = new Schema(&#x27;UserSchema&#x27;, {\n  name: { type: &#x27;string&#x27; },\n  age: { type: &#x27;number&#x27; }\n});\nlet User = mongolass.model(&#x27;User&#x27;, UserSchema);\n\nUser\n  .insertOne({ name: &#x27;nswbmw&#x27;, age: &#x27;wrong age&#x27; })\n  .exec()\n  .then(console.log)\n  .catch(console.error);\n</code></pre>\n\n<h2>What about Mongolass</h2>\n<p>Mongolass retains the api of <a href=\"https://github.com/mongodb/node-mongodb-native\">node-mongodb-native</a>, and draws useful features of mongoose. Compared with node-mongodb-native, Mongolass has following three features:</p>\n<ol>\n<li>\n<p>Elegant connection. eg:</p>\n<p><strong>mongodb</strong></p>\n<pre class=\"prettyprint\"><code>MongoClient.connect(..., function(err, db) {\n  db.listCollections()\n})\n</code></pre><p><strong>Mongolass</strong></p>\n<pre class=\"prettyprint\"><code>mongolass.connect(...)\nmongolass.listCollections()\n</code></pre></li>\n<li>\n<p>Optional schema, only used for parameter validation before insert document to mongodb.</p>\n</li>\n<li>\n<p>Awesome plugin system. eg: <code>beforeInsert</code>, <code>afterFind</code> and so on.</p>\n</li>\n</ol>\n<h2>Schema</h2>\n<p>see <a href=\"https://github.com/nswbmw/another-json-schema\">another-json-schema</a>.</p>\n<h2>Plugins</h2>\n<p>Mongolass has some built-in plugins, only for <code>find</code> and <code>findOne</code>.</p>\n<ul>\n<li><a href=\"http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#findOne\">limit</a></li>\n<li><a href=\"http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#findOne\">sort</a></li>\n<li><a href=\"http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#findOne\">fields(alias: select)</a></li>\n<li><a href=\"http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#findOne\">skip</a></li>\n<li><a href=\"http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#findOne\">hint</a></li>\n<li><a href>populate</a></li>\n<li><a href=\"http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#findOne\">explain</a></li>\n<li><a href=\"http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#findOne\">snapshot</a></li>\n<li><a href=\"http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#findOne\">timeout</a></li>\n<li><a href=\"http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#findOne\">tailable</a></li>\n<li><a href=\"http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#findOne\">tailableRetryInterval</a></li>\n<li><a href=\"http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#findOne\">numberOfRetries</a></li>\n<li><a href=\"http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#findOne\">awaitdata</a></li>\n<li><a href=\"http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#findOne\">oplogReplay</a></li>\n<li><a href=\"http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#findOne\">exhaust</a></li>\n<li><a href=\"http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#findOne\">batchSize</a></li>\n<li><a href=\"http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#findOne\">returnKey</a></li>\n<li><a href=\"http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#findOne\">maxScan</a></li>\n<li><a href=\"http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#findOne\">min</a></li>\n<li><a href=\"http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#findOne\">max</a></li>\n<li><a href=\"http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#findOne\">showDiskLoc</a></li>\n<li><a href=\"http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#findOne\">comment</a></li>\n<li><a href=\"http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#findOne\">raw</a></li>\n<li><a href=\"http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#findOne\">readPreference</a></li>\n<li><a href=\"http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#findOne\">partial</a></li>\n<li><a href=\"http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html#findOne\">maxTimeMS</a></li>\n</ul>\n<h4>Register plugin</h4>\n<pre class=\"prettyprint\"><code>mongolass.plugin(pluginName, hooks);&#x2F;&#x2F; register global plugin\nUser.plugin(pluginName, hooks);&#x2F;&#x2F; register model plugin\n</code></pre><p>examples:</p>\n<pre class=\"prettyprint\"><code>User.plugin(&#x27;mw2&#x27;, {\n  beforeInsert: function (...args) {\n  },\n  afterFind: function* (result, ...args) {\n    console.log(result, args);\n    ...\n  }\n});\n\nmongolass.plugin(&#x27;mw1&#x27;, {\n  beforeFind: function (...args) {\n    console.log(ctx._op);\n    console.log(ctx._args);\n    console.log(args);\n    ...\n  }\n});\n\nyield User.find().mw1().mw2().exec()&#x2F;&#x2F; equal: yield User.find().mw1().mw2()\nUser.find().mw2().mw1().exec().then(...).catch(...)\nUser.find().mw1().mw2().exec(function (err, res) {\n  console.log(err, res)\n})\n</code></pre><p><strong>NOTE</strong>: Different order of calling plugins will output different results.</p>\n<h2>Test</h2>\n<pre class=\"prettyprint\"><code>$ npm test (coverage 100%)\n</code></pre><h2>License</h2>\n<p>MIT</p>\n</div>","title":"Mongolass——一个类 mongoose 的 MongoDB 驱动库","last_reply_at":"2016-11-12T11:44:16.316Z","good":false,"top":false,"reply_count":4,"visit_count":1002,"create_at":"2016-03-09T12:52:10.504Z","author":{"loginname":"nswbmw","avatar_url":"https://avatars.githubusercontent.com/u/4279697?v=3&s=120"}},{"id":"58076081487e1e4578afb65e","author_id":"580760420bab808265185f3a","tab":"job","content":"<div class=\"markdown-text\"><h2>一、公司简介</h2>\n<p>818Gaming位于柬埔寨王国首府金边市，公司成立于2010年，在柬埔寨王国有合法注册执照，主要从事多平台游戏系统的研发。公司目前在柬埔寨、新加坡、马来西亚、缅甸、俄罗斯设立多个分部，业务遍布世界各地，拥有上百名员工。公司产品经过多年的市场验证，拥有稳定的业务。现公司发展扩大规模，诚邀各路IT人士加入我们的团队！</p>\n<p><strong>公司为外籍员工提供：</strong>\n<code>包吃包住</code>、<code>水果饮料</code>、<code>定期团建</code>、<code>40天带薪休假</code>、<code>2次往返机票</code>、<code>年终奖金</code>、<code>管理享有年终分红</code>，还有更多其它福利。</p>\n<h2>二、工作挑战</h2>\n<ol>\n<li>公司业务独立运行着多个Linux服务器集群，近百台服务器，并且还在不断扩展中。</li>\n<li>公司软体系统需要针对集群不断进行网络安全防范、大数据处理、高并发、高可用，及用户体验等进行持续优化，以适应业务的快速增长需求。</li>\n<li>这是一份充满挑战性的工作，相信您的加入能够帮助到公司业务的稳定和增长，您自己也能从中得到难得的学习机会和宝贵的经验，让我们共同成长。</li>\n</ol>\n<h2>三、中级前端开发工程师</h2>\n<p><strong>崗位職責：</strong></p>\n<ol>\n<li>前端框架的設計與實現 ，並配合後端研發人員最終完成產品整體開發；</li>\n<li>各業務模塊前端程式碼獨立開發，平臺易用性與用戶體驗的持續改進；</li>\n<li>主導進行移動端開發，對互動效果有較為深入的認識；</li>\n<li>深入理解產品的需求和定位，參與產品的設計與研發，能提出可行的意見和措施；</li>\n<li>協助其他成員解决工作中遇到的難題，並協助上級完成整體目標；</li>\n<li>Web前沿技術研究和新技術調研。</li>\n</ol>\n<p><strong>任職要求：</strong></p>\n<ol>\n<li>前端開發經驗1年以上，靈活運用常見類別庫，如:Bootstrap,jQuery,AngularJS,ReactJS；</li>\n<li>熟悉各主流瀏覽器間的差异，能快速定位和解决各種相容難題；</li>\n<li>對表現與數據分離、Web語義化等有深刻理解，瞭解CMD、AMD規範；</li>\n<li>對前端開發、模組化開發、前/後端分離有自己的獨立見解；</li>\n<li>良好的程式碼、檔案編寫習慣，良好的英文電腦資料閱讀能力；</li>\n<li>思維活躍、具有較强的鑽研能力、領悟能力和獨立解决問題的能力；</li>\n<li>熱情，敬業，能承受一定的工作壓力。</li>\n</ol>\n<p><strong>薪资待遇：7K-15K，具体详谈。</strong></p>\n<h2>四、初级和高级前端工程师招聘</h2>\n<p>同时公司非常注重人才的储备和培养，如果您是处于没有多少经验的初级阶段，只要您拥有良好的网路技术基础，有志于从事互联网行业，有刻苦钻研的精神，欢迎您联系我们，公司将为您提供一个快速成长的环境和机会。\n如果您是富有经验的高级前端工程师，也欢迎您与我们联系，我们将为您提供15K-25K范围的薪资待遇。</p>\n<h2>五、其它岗位招聘</h2>\n<p>公司长期招聘 <code>PHP</code> / <code>前端开发 &amp; HTML5</code> / <code>LINUX运维工程师</code> / <code>AS3.0</code> / <code>C++</code> / <code>移动开发</code> / <code>美工</code> 等IT人才，有意向者请与我们联系。</p>\n<h2>六、常见问题</h2>\n<p><strong>问：柬埔寨安全吗？</strong></p>\n<blockquote>\n<p>答：很多人会问柬埔寨安全吗？会不会很乱？其实柬埔寨的治安是很好的，特别是首府金边市的治安都是很好的。\n当然作为外籍员工，我们不建议您单独外出，最好约同事结伴而行，或者让公司司机接送。也不要单独前往灯光昏暗和偏僻的地方，这在哪个国家都是一样的。</p>\n</blockquote>\n<p><strong>问：柬埔寨会有种族歧视吗？</strong></p>\n<blockquote>\n<p>答：柬埔寨是一个完全开放的国家，与中国的关系非常友好，对华人也非常友好，不像其他国家会排华。柬埔寨的商业都是由华人支撑起来的，几乎所有的公司、商店、工厂都是华人开设的，华人和柬埔寨原住民通婚率也非常的高。柬埔寨通用美元、柬币，人民币也已允许合法流通。中国人到柬埔寨都可以获得落地签证。</p>\n</blockquote>\n<p><strong>问：为什么不从柬埔寨招人？</strong></p>\n<blockquote>\n<p>答：柬埔寨仍然是一个人才极度匮乏的国家，国家经过了红色高棉大屠杀后，拥有IT知识的人才实在是太少了，几乎所有高级人才都依靠从外国引进，虽然这里不如中国的繁荣和发达，但相信这里一定会有您的机会。</p>\n</blockquote>\n<p><strong>问：我符合招聘要求吗？</strong></p>\n<blockquote>\n<p>答：作为一家以华人员工为主的IT公司，公司非常注重中长期的人才培养和储备，公司希望借助当前柬埔寨与中国关系非常友好，以及受惠于中国的一带一路政策，更多的招聘华人员工。公司长期招聘初级、中级、高级IT技术人才，只要您符合招聘要求，不限工作经验，只需有较好的相关专业基础即可。即使您是刚从学校毕业的新人，请放心的与我们联系。</p>\n</blockquote>\n<p><strong>问：薪资怎么样？</strong></p>\n<blockquote>\n<p>答：公司提供的薪资和福利待遇，肯定比在中国要高很多。只要您具有良好的相关专业基础，薪资最少都是7000元人民币起步，<code>请注意这里说的是初级人员的最低薪资哦</code>。</p>\n</blockquote>\n<p><strong>问：怎么面试？</strong></p>\n<blockquote>\n<p>答：可通过skype或qq远程面试。</p>\n</blockquote>\n<p><strong>问：工作地点在哪里？</strong></p>\n<blockquote>\n<p>答：柬埔寨王国首府 金边市。</p>\n</blockquote>\n<p><strong>问：公司主营业务？</strong></p>\n<blockquote>\n<p>答：研发支持PC、iOS、Android、Pad等设备的游戏平台和后台系统，及在线电子游戏等。</p>\n</blockquote>\n<p><strong>问：会不会有语言沟通障碍？</strong></p>\n<blockquote>\n<p>答：柬埔寨通用柬语、华语、英语。\n在工作上，公司官方语言是华语，公司以华人居多，没有沟通障碍。\n在生活上，柬埔寨华人非常的多，几乎所有的商店都有人会讲华语，而且您外出可以让司机翻译接送，无&gt; 需担心语言障碍。</p>\n</blockquote>\n<p><strong>问：办公环境怎么样？</strong></p>\n<blockquote>\n<p>答：公司在金边市中心高档写字楼办公，有良好的办公环境。</p>\n</blockquote>\n<p><strong>问：生活居住环境怎么样？</strong></p>\n<blockquote>\n<p>答：公司在市中心租用独栋楼房作为员工宿舍，外出交通便利，周边有各类商店，生活方便。并且有保姆负责日常卫生的打扫，有洗衣机可供洗衣服。有些宿舍还提供健身房、台球室等娱乐休闲设施。</p>\n</blockquote>\n<p><strong>问：食堂怎么样？</strong></p>\n<blockquote>\n<p>答：食堂由华人厨师负责，口味不成问题，每餐两荤两素一汤，菜式丰富，提供水果饮料。</p>\n</blockquote>\n<p><strong>问：基本待遇有哪些？</strong></p>\n<blockquote>\n<p>答：公司为所有员工免费提供吃住及基本生活用品，您在这里基本上不用任何花费。</p>\n</blockquote>\n<p><strong>问：休假怎么安排？</strong></p>\n<blockquote>\n<p>答：每周休假1天，根据不同工作岗位，一年还有2-4次带薪休假，由公司报销2次来回机票。公司的原则是尽量不加班，平时公司都是很少加班的，根据我找中国同事了解的情况，要比在中国工作轻松。</p>\n</blockquote>\n<p><strong>问：我要怎么过来？</strong></p>\n<blockquote>\n<p>答：您只需办好护照，无需办理签证，柬埔寨是落地签。您订机票前请与我们工作人员联系协助您查询机票。您到金边机场下飞机后，我们会安排工作人员接机，协助您办理落地签证及出关。您首次过来的机票和签证，由公司为您报销。</p>\n</blockquote>\n<p><strong>问：加薪问题？</strong></p>\n<blockquote>\n<p>答：您工作三个月后，如果您的工作能力OK，公司会根据您的能力情况加薪1000-3000元，以后根据您工作能力的提升会再加薪。</p>\n</blockquote>\n<p><strong>问：如何汇款回中国？</strong></p>\n<blockquote>\n<p>答：公司附近就有中国工商银行，您可以直接到银行把钱存到您的个人账户。</p>\n</blockquote>\n<p><strong>问：我为什么要出国到柬埔寨工作？</strong></p>\n<blockquote>\n<p>答：这是一份充满挑战的工作，让您有机会接触到高性能服务器、大型数据库、海量数据存储设备，及高性能Web服务器等大型网站架构技术。在这里您可以得到快速的成长，为您的工作履历加分。并且公司已为您承担了几乎所有的生活费用，在这里您更能够把赚到的钱存起来，让您更快的实现自己的生活梦想。\n<code>不管是为了挑战更有难度和意义的工作，还是为了更快的实现您和家人的生活梦想，都值得您加入我们的团队！</code>\n简单举例，您来到公司，公司免费提供吃住及基本生活用品，您在这里基本上不用任何花费，您的工资是可以全部存下来的，只需工作两三年就足够您回中国买房的首付了。\n假如您在中国月薪是5000元，来到这里刚开始是7000元，您在中国5000元还要扣除房租、伙食费、生活费等，每个月能存下来的钱最多只有2000多元，而您来到这里每月7000元是不需要支付房租、伙食费、生活费的，7000元是您可以全部存下来的，所以您在中国5000元和来这里7000元相差的就不是2000元，而是5000元。\n而且公司拥有较好的加薪制度，来3-6个月后公司会根据您的个人能力加薪到8000-10000元，以后随着您个人能力不断的成长还会加薪，同时还有丰厚的年终奖金。</p>\n</blockquote>\n<p><strong>更多疑问，欢迎您联系我咨询，我是818Gaming人事部丽雅LeYa，竭诚为您解答相关问题。</strong></p>\n<h2>六、联系方式</h2>\n<p>请加我的QQ <code>3551744079</code>，请发简历到邮箱<code>leya.hr#818gaming.com</code> 或  <code>3551744079#qq.com</code>（请把<code>#</code>替换成<code>@</code>），谢谢！\n本公司直接招聘，您无需支付任何中介费用，正规录用合同，您的权益受法律保护。\n本招聘长期有效，欢迎投简历，谢谢！</p>\n</div>","title":"[国外][7K-25K] 818Gaming招聘初级、中级、高级前端工程师","last_reply_at":"2016-11-12T11:15:24.373Z","good":false,"top":false,"reply_count":9,"visit_count":490,"create_at":"2016-10-19T12:01:05.680Z","author":{"loginname":"818gaming","avatar_url":"https://avatars.githubusercontent.com/u/22934727?v=3&s=120"}},{"id":"565112244668f75208da4025","author_id":"50b5bc5d637ffa4155091236","tab":"ask","content":"<div class=\"markdown-text\"><p>有没有好的调试工具?</p>\n</div>","title":"async/await出错了怎么调试?","last_reply_at":"2016-11-12T10:41:48.000Z","good":false,"top":false,"reply_count":19,"visit_count":1631,"create_at":"2015-11-22T00:53:56.776Z","author":{"loginname":"yakczh","avatar_url":"https://avatars.githubusercontent.com/u/6591466?v=3&s=120"}},{"id":"57deb4ee7e77820e3acfdff6","author_id":"54be68f4514ea9146862acc0","tab":"share","content":"<div class=\"markdown-text\"><p>嘿嘿😝，小教程起名为  Web 包教不包会   （希望唐少不要打我😄）</p>\n<p>面向萌新们，老鸟无视吧。仓库地址在 <a href=\"https://github.com/hugojing/web-lessons\">https://github.com/hugojing/web-lessons</a></p>\n<h1>《使用 Babel + Webpack 编写 ECMAScript 2015 代码》</h1>\n<h2>目标</h2>\n<p>建立一个 lesson2 项目，在其中编写代码。</p>\n<p>在 JS 文件中编写 ECMAScript 2015 代码，最终打包输出 ES5 代码。</p>\n<p>当在浏览器中访问 <a href=\"http://localhost:8080\">http://localhost:8080</a> 时，输出一个页面，在其中点击按钮、派出一只小精灵。</p>\n<p><img src=\"https://raw.githubusercontent.com/hugojing/web-lessons/master/lesson2/lesson2.gif\" alt></p>\n<h2>知识点</h2>\n<ol>\n<li>学习 Node 项目的初始化</li>\n<li>学习 Babel + Webpack 的使用</li>\n<li>学习 ES2015 的部分语法</li>\n</ol>\n<h2>课程内容</h2>\n<h3>使用 Babel 的原因</h3>\n<p>可能你注意到了，上一节课我们编写的是 ES2015 代码，虽然在 Chrome 中可以运行，但是在其他浏览器上就不一定了。这就是我们使用 Babel 的原因所在。</p>\n<p>有了 Babel，ES2015 代码就可以转译为各个浏览器普遍能运行的 ES5 代码。</p>\n<p>但是 Babel 只有转译功能，对于 ES2015 modules，它是默认转译为 CommonJS 的（require 关键字）。</p>\n<p>浏览器无法直接加载 CommonJS 模块，因此还需要 Webpack 来实现 JS 模块加载功能。</p>\n<blockquote>\n<p>注意，Webpack 是一个前端模块加载器 + 打包工具。咱们此次只用到它前端模块加载功能之一 —— JS 模块加载。你当然可以选择其他 JS 模块加载器，比如 Browserify。</p>\n</blockquote>\n<p>将它们安装到 Node 项目中，首先需要初始化一个 Node 项目。</p>\n<h3>初始化一个 Node 项目</h3>\n<p>执行初始化命令，</p>\n<pre class=\"prettyprint language-bash\"><code>$ npm init\n</code></pre><p>填入必要信息，完成。</p>\n<p>完成之后项目中会多出一个 <code>package.json</code> 文件，即为初始化成功。</p>\n<h3>安装 Babel 和 Wabpack 到项目</h3>\n<p>安装 babel-core 和它的 babel-preset-es2015 插件，并写入到 <code>package.json</code> 的 <code>devDependencies</code> 中。</p>\n<pre class=\"prettyprint language-bash\"><code>$ npm install --save-dev babel-core babel-preset-es2015\n</code></pre><p>安装 webpack 和它的 babel-loader 插件，并写入到 <code>package.json</code> 的 <code>devDependencies</code> 中。</p>\n<pre class=\"prettyprint language-bash\"><code>$ npm install --save-dev webpack babel-loader\n\n</code></pre><p>安装好之后，我们就可以在运行代码之前执行 <code>webpack</code> 命令进行打包。</p>\n<p>为了方便使用，可以给命令一个别名，写到 <code>package.json</code> 的 <code>scripts</code> 中。</p>\n<p>例如：</p>\n<pre class=\"prettyprint language-json\"><code>&quot;scripts&quot;: {\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;,\n    &quot;build&quot;: &quot;webpack -p --progress --hide-modules&quot;\n}\n</code></pre><blockquote>\n<p>小插曲：还记得前几节的小工具 <code>http-server</code> 吗？也可安装到项目中来，抛弃原本在全局使用的方式。</p>\n</blockquote>\n<p>安装：</p>\n<pre class=\"prettyprint language-bash\"><code>$ npm install --save-dev http-server\n</code></pre><p>此后项目中可以使用 <code>http-server [输出目录]</code> 命令来启动服务器。</p>\n<p>我们同样写入 npm scripts：</p>\n<pre class=\"prettyprint language-json\"><code>&quot;scripts&quot;: {\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;,\n    &quot;build&quot;: &quot;webpack -p --progress --hide-modules&quot;,\n    &quot;serve&quot;: &quot;http-server dist&quot;\n}\n</code></pre><p>这样，之后就可以使用 <code>npm run build</code> 和 <code>npm run serve</code> 命令了，更加语义化。</p>\n<h3>编写 Babel 和 Webpack 的配置文件</h3>\n<p>新建一个文件：<code>.babelrc</code>， 编写 Babel 的配置文件：</p>\n<pre class=\"prettyprint\"><code>详见本目录下 .babelrc 文件\n</code></pre><p>新建一个文件：<code>webpack.config.js</code>， 编写 Webpack 的配置文件：</p>\n<pre class=\"prettyprint\"><code>详见本目录下 webpack.config.js 文件\n</code></pre><blockquote>\n<p>本节不铺开讲配置文件</p>\n</blockquote>\n<h3>用 HTML 写内容</h3>\n<p>新建 <code>/dist</code> 和 <code>/src</code> 目录。</p>\n<p>新建一个文件：<code>/dist/index.html</code>，编写 HTML 文档：</p>\n<pre class=\"prettyprint language-html\"><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;ES2015 宠物小精灵&lt;&#x2F;title&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;.&#x2F;style.css&quot;&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;button class=&quot;btn&quot;&gt;决定就是你了！&lt;&#x2F;button&gt;\n    &lt;script src=&quot;.&#x2F;main.js&quot; charset=&quot;utf-8&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n</code></pre><h3>用 CSS 写样式</h3>\n<p>新建一个文件：<code>/dist/style.css</code>，编写 CSS 文件：</p>\n<pre class=\"prettyprint language-css\"><code>html, body {\n    width: 100%;\n    height: 100%;\n    margin: 0;\n}\nbody {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    background-color: whitesmoke;\n    font-family: &quot;HelveticaNeue-Light&quot;, &quot;Helvetica Neue Light&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, &quot;Lucida Grande&quot;, sans-serif;\n}\n.btn {\n    outline: none;\n    border: none;\n    border-radius: 2px;\n    padding: 10px;\n    color: #fff;\n    background: indianred;\n}\n</code></pre><h3>用 JS 写行为</h3>\n<p>新建一个文件：<code>/src/main.js</code>，编写 JS 文件：</p>\n<p>主要内容就是监听刚刚在 HTML 中写的那个按钮，当点击时就随机给出一只小精灵。</p>\n<p>因为我们可以毫无顾忌的写 ES2015 代码了，所以直接引入第三方模块。</p>\n<p>首先需要安装：</p>\n<pre class=\"prettyprint language-bash\"><code>$ npm install --save pokemon-gif\n</code></pre><p>然后开写：</p>\n<pre class=\"prettyprint language-js\"><code>import pokemonGif from &#x27;pokemon-gif&#x27;\n\nconst btn = document.getElementsByClassName(&#x27;btn&#x27;)[0]\n\nbtn.addEventListener(&#x27;click&#x27;, () =&gt; {\n    console.log(&#x27;Clicked!&#x27;)\n    const randomId = Math.ceil(Math.random() * 721)\n    const gifUrl = pokemonGif(randomId)\n    console.log(gifUrl)\n    if (gifUrl) {\n        const img = document.createElement(&#x27;img&#x27;)\n        img.src = gifUrl\n        const body = document.getElementsByTagName(&#x27;body&#x27;)[0]\n        body.removeChild(btn)\n        body.appendChild(img)\n    }\n})\n</code></pre><h3>打包，启动服务</h3>\n<p>打包 :</p>\n<pre class=\"prettyprint language-bash\"><code>$ npm run build\n</code></pre><p>启动服务：</p>\n<pre class=\"prettyprint language-bash\"><code>$ npm run serve\n</code></pre><p>打开浏览器输入网址 <code>http://localhost:8080</code> 即可查看效果。</p>\n</div>","title":"仿照唐少做了个前端小教程，新手向，也是自己巩固一下《使用 Babel + Webpack 编写 ECMAScript 2015 代码》","last_reply_at":"2016-11-12T09:50:53.080Z","good":true,"top":false,"reply_count":22,"visit_count":3692,"create_at":"2016-09-18T15:38:22.136Z","author":{"loginname":"HugoJing","avatar_url":"https://avatars.githubusercontent.com/u/8682847?v=3&s=120"}},{"id":"579a301df0d4b46026ba55e5","author_id":"577115b4889605241796f8f7","tab":"ask","content":"<div class=\"markdown-text\"><h2>新手司机上路。。。只能无耻的当一回伸手党了</h2>\n<p>最近在研究mongodb，不过想要看一波api文档的时候，那个npm上给的github.io链接貌似挂了\n<a href=\"http://mongodb.github.io/node-mongodb-native/\">就是这个http://mongodb.github.io/node-mongodb-native/</a>\n不知道是不是网络的原因。。。<br>\n反正我打不开<br>\n其他地方都找不到<br>\n有没有文档的老司机能给我一份？<br>\n感激不尽</p>\n</div>","title":"【无耻的伸手党】跪求npm里面的mongodb包的api文档","last_reply_at":"2016-11-12T08:44:12.820Z","good":false,"top":false,"reply_count":5,"visit_count":667,"create_at":"2016-07-28T16:17:33.588Z","author":{"loginname":"Char-Ten","avatar_url":"https://avatars.githubusercontent.com/u/17474452?v=3&s=120"}},{"id":"58267c0e6c4502be6ed87b62","author_id":"57294b8a3f27a7c841bcb8d2","tab":"ask","content":"<div class=\"markdown-text\"><p>使用Request模块发起HTTP请求导致Error: read ECONNRESET，使用Postman，curl都能正确得到响应。忙了一下午，通过tcpdump抓包、WireShark查看抓包信息，发现Request模块发送HTTP请求Host字段为小写host，我们的服务器只支持大写所以导致Error: read ECONNRESET。\n\t解决问题很简单了，找到request模块的request.js文件，大约290行左右\n\t    var hostHeaderName = self.originalHostHeaderName || 'host’\nself.setHeader(hostHeaderName, self.uri.hostname)\n\t改为\n\t    var hostHeaderName = self.originalHostHeaderName || 'Host’\nself.setHeader(hostHeaderName, self.uri.hostname)\n\t这到底算不算Bug哪？</p>\n</div>","title":"一个大小写问题引发的ECONNRESET","last_reply_at":"2016-11-12T08:34:22.853Z","good":false,"top":false,"reply_count":2,"visit_count":90,"create_at":"2016-11-12T02:18:54.784Z","author":{"loginname":"sunyoboy","avatar_url":"https://avatars.githubusercontent.com/u/11656719?v=3&s=120"}},{"id":"5804cbb8fdf3bd3d6511870c","author_id":"576fda64bef3ca5c17dedfec","tab":"ask","content":"<div class=\"markdown-text\"><p>关于session和cookie理解了好久，总是似懂非懂，想请问一下express的express-session中间件发挥了什么作用？\n按我的理解是\n首先，设置了cookie\n其次，将该session存到了mongodb里面</p>\n<p>问题是，cookie里面存的信息是啥？和mongodb里面一样？还是说只是个标识？就算解密了也只是个标识？</p>\n<p>现在的项目是用的hapi，然后cookie存的是用户名，redis存的是具体的用户信息。其实cookie也可以只存没有意义的一个标识吗？然后查找redis的该标识对应的用户来获取具体信息对吗？</p>\n<p>先谢谢大家解答。</p>\n<pre class=\"prettyprint language-js\"><code>app.use(cookieParser());\napp.use(session({\n  secret: settings.cookieSecret,\n  key: settings.db,&#x2F;&#x2F;cookie name\n  cookie: {maxAge: 1000 * 60 * 60 * 24 * 30},&#x2F;&#x2F;30 days\n  store: new MongoStore({\n    url: &#x27;mongodb:&#x2F;&#x2F;localhost&#x2F;blog&#x27;\n  })\n}));\n</code></pre></div>","title":"express-session的疑问","last_reply_at":"2016-11-12T08:28:32.783Z","good":false,"top":false,"reply_count":3,"visit_count":425,"create_at":"2016-10-17T13:01:44.452Z","author":{"loginname":"zp1112","avatar_url":"https://avatars.githubusercontent.com/u/14245159?v=3&s=120"}},{"id":"5826c2dde885ce5a3938283e","author_id":"5629da22e6a3804c58159198","tab":"share","content":"<div class=\"markdown-text\"><p>发现国内daocloud.io做的还真不错啊~</p>\n<p>顺便还集成了他们的daovoice玩了一把,这在线聊天UI做的真不赖, app反馈问题之类的,完美~</p>\n<p>最新版本: latest 镜像地址: <a href=\"http://daocloud.io/qxl1231/lb-vue2\">daocloud.io/qxl1231/lb-vue2</a></p>\n<blockquote>\n<p><a href=\"https://github.com/qxl1231/generator-loopback-vue\">https://github.com/qxl1231/generator-loopback-vue</a></p>\n</blockquote>\n<p>可以点这个地址来把玩下</p>\n<blockquote>\n<p><a href=\"http://loopback-vue.daoapp.io/\">http://loopback-vue.daoapp.io/</a></p>\n</blockquote>\n<p>😄<br>\n我不是托,这个daovoice确实不错\n<img src=\"//dn-cnode.qbox.me/FiOz7bWIpekqc9U83YtpTTMTiA-w\" alt=\"untitled1.png\"></p>\n</div>","title":"最近玩了一下docker,良心推荐个好东西","last_reply_at":"2016-11-12T08:07:34.807Z","good":false,"top":false,"reply_count":1,"visit_count":164,"create_at":"2016-11-12T07:21:01.904Z","author":{"loginname":"qxl1231","avatar_url":"https://avatars.githubusercontent.com/u/8305742?v=3&s=120"}},{"id":"5826ae176c4502be6ed87b68","author_id":"556d0938638127f01f74de0b","tab":"ask","content":"<div class=\"markdown-text\"><p>Nodejs连接一个mysql中的多个db实例有什么好方法么？</p>\n</div>","title":"Nodejs连接一个mysql中的多个db实例有什么好方法么？","last_reply_at":"2016-11-12T07:03:00.700Z","good":false,"top":false,"reply_count":2,"visit_count":82,"create_at":"2016-11-12T05:52:23.585Z","author":{"loginname":"lxf","avatar_url":"https://avatars.githubusercontent.com/u/4726357?v=3&s=120"}},{"id":"5660f8f9d0bc14ae27939b37","author_id":"54475fdf649ac9220757b8ed","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>原文链接：<a href=\"https://blog.coding.net/blog/React-server-rendering\">https://blog.coding.net/blog/React-server-rendering</a></p>\n</blockquote>\n<p>React 提供了两个方法 <code>renderToString</code> 和 <code>renderToStaticMarkup</code> 用来将组件（Virtual DOM）输出成 HTML 字符串，这是 React 服务器端渲染的基础，它移除了服务器端对于浏览器环境的依赖，所以让服务器端渲染变成了一件有吸引力的事情。</p>\n<p>服务器端渲染除了要解决对浏览器环境的依赖，还要解决两个问题：</p>\n<ul>\n<li>前后端可以共享代码</li>\n<li>前后端路由可以统一处理</li>\n</ul>\n<p>React 生态提供了很多选择方案，这里我们选用 <a href=\"http://rackt.org/redux/docs/introduction/index.html\">Redux</a> 和 <a href=\"https://github.com/rackt/react-router\">react-router</a> 来做说明。</p>\n<h2>Redux</h2>\n<p><a href=\"http://rackt.org/redux/docs/introduction/index.html\">Redux</a> 提供了一套类似 Flux 的单向数据流，整个应用只维护一个 Store，以及面向函数式的特性让它对服务器端渲染支持很友好。</p>\n<h3>2 分钟了解 Redux 是如何运作的</h3>\n<p>关于 Store：</p>\n<ul>\n<li>整个应用只有一个唯一的 Store</li>\n<li>Store 对应的状态树（State），由调用一个 reducer 函数（root reducer）生成</li>\n<li>状态树上的每个字段都可以进一步由不同的 reducer 函数生成</li>\n<li>Store 包含了几个方法比如 <code>dispatch</code>, <code>getState</code> 来处理数据流</li>\n<li>Store 的状态树只能由 <code>dispatch(action)</code> 来触发更改</li>\n</ul>\n<p>Redux 的数据流：</p>\n<ul>\n<li>action 是一个包含 <code>{ type, payload }</code> 的对象</li>\n<li>reducer 函数通过 <code>store.dispatch(action)</code> 触发</li>\n<li>reducer 函数接受 <code>(state, action)</code> 两个参数，返回一个新的 state</li>\n<li>reducer 函数判断 <code>action.type</code> 然后处理对应的 <code>action.payload</code> 数据来更新状态树</li>\n</ul>\n<p>所以对于整个应用来说，一个 Store 就对应一个 UI 快照，服务器端渲染就简化成了在服务器端初始化 Store，将 Store 传入应用的根组件，针对根组件调用 <code>renderToString</code> 就将整个应用输出成包含了初始化数据的 HTML。</p>\n<h2>react-router</h2>\n<p><a href=\"https://github.com/rackt/react-router\">react-router</a> 通过一种声明式的方式匹配不同路由决定在页面上展示不同的组件，并且通过 props 将路由信息传递给组件使用，所以只要路由变更，props 就会变化，触发组件 re-render。</p>\n<p>假设有一个很简单的应用，只有两个页面，一个列表页 <code>/list</code> 和一个详情页 <code>/item/:id</code>，点击列表上的条目进入详情页。</p>\n<p>可以这样定义路由，<code>./routes.js</code></p>\n<pre class=\"prettyprint language-javascript\"><code>import React from &#x27;react&#x27;;\nimport { Route } from &#x27;react-router&#x27;;\nimport { List, Item } from &#x27;.&#x2F;components&#x27;;\n\n&#x2F;&#x2F; 无状态（stateless）组件，一个简单的容器，react-router 会根据 route\n&#x2F;&#x2F; 规则匹配到的组件作为 &#96;props.children&#96; 传入\nconst Container = (props) =&gt; {\n  return (\n    &lt;div&gt;{props.children}&lt;&#x2F;div&gt;\n  );\n};\n\n&#x2F;&#x2F; route 规则：\n&#x2F;&#x2F; - &#96;&#x2F;list&#96; 显示 &#96;List&#96; 组件\n&#x2F;&#x2F; - &#96;&#x2F;item&#x2F;:id&#96; 显示 &#96;Item&#96; 组件\nconst routes = (\n  &lt;Route path=&quot;&#x2F;&quot; component={Container} &gt;\n    &lt;Route path=&quot;list&quot; component={List} &#x2F;&gt;\n    &lt;Route path=&quot;item&#x2F;:id&quot; component={Item} &#x2F;&gt;\n  &lt;&#x2F;Route&gt;\n);\n\nexport default routes;\n</code></pre><p>从这里开始，我们通过这个非常简单的应用来解释实现服务器端渲染前后端涉及的一些细节问题。</p>\n<h2>Reducer</h2>\n<p>Store 是由 reducer 产生的，所以 reducer 实际上反映了 Store 的状态树结构</p>\n<p><code>./reducers/index.js</code></p>\n<pre class=\"prettyprint language-javascript\"><code>import listReducer from &#x27;.&#x2F;list&#x27;;\nimport itemReducer from &#x27;.&#x2F;item&#x27;;\n\nexport default function rootReducer(state = {}, action) {\n  return {\n    list: listReducer(state.list, action),\n\titem: itemReducer(state.item, action)\n  };\n}\n</code></pre><p><code>rootReducer</code> 的 <code>state</code> 参数就是整个 Store 的状态树，状态树下的每个字段对应也可以有自己的\nreducer，所以这里引入了 <code>listReducer</code> 和 <code>itemReducer</code>，可以看到这两个 reducer\n的 state 参数就只是整个状态树上对应的 <code>list</code> 和 <code>item</code> 字段。</p>\n<p>具体到 <code>./reducers/list.js</code></p>\n<pre class=\"prettyprint language-javascript\"><code>const initialState = [];\n\nexport default function listReducer(state = initialState, action) {\n  switch(action.type) {\n  case &#x27;FETCH_LIST_SUCCESS&#x27;: return [...action.payload];\n  default: return state;\n  }\n}\n</code></pre><p>list 就是一个包含 items 的简单数组，可能类似这种结构：<code>[{ id: 0, name: 'first item'}, {id: 1, name: 'second item'}]</code>，从 <code>'FETCH_LIST_SUCCESS'</code> 的 <code>action.payload</code> 获得。</p>\n<p>然后是 <code>./reducers/item.js</code>，处理获取到的 item 数据</p>\n<pre class=\"prettyprint language-javascript\"><code>const initialState = {};\n\nexport default function listReducer(state = initialState, action) {\n  switch(action.type) {\n  case &#x27;FETCH_ITEM_SUCCESS&#x27;: return [...action.payload];\n  default: return state;\n  }\n}\n</code></pre><h2>Action</h2>\n<p>对应的应该要有两个 action 来获取 list 和 item，触发 reducer 更改 Store，这里我们定义 <code>fetchList</code> 和 <code>fetchItem</code> 两个 action。</p>\n<p><code>./actions/index.js</code></p>\n<pre class=\"prettyprint language-javascript\"><code>import fetch from &#x27;isomorphic-fetch&#x27;;\n\nexport function fetchList() {\n  return (dispatch) =&gt; {\n    return fetch(&#x27;&#x2F;api&#x2F;list&#x27;)\n\t\t.then(res =&gt; res.json())\n\t\t.then(json =&gt; dispatch({ type: &#x27;FETCH_LIST_SUCCESS&#x27;, payload: json }));\n  }\n}\n\nexport function fetchItem(id) {\n  return (dispatch) =&gt; {\n    if (!id) return Promise.resolve();\n    return fetch(&#96;&#x2F;api&#x2F;item&#x2F;${id}&#96;)\n\t\t.then(res =&gt; res.json())\n\t\t.then(json =&gt; dispatch({ type: &#x27;FETCH_ITEM_SUCCESS&#x27;, payload: json }));\n  }\n}\n</code></pre><p><a href=\"https://github.com/matthew-andrews/isomorphic-fetch\">isomorphic-fetch</a> 是一个前后端通用的 Ajax 实现，前后端要共享代码这点很重要。</p>\n<p>另外因为涉及到异步请求，这里的 action 用到了 thunk，也就是函数，redux 通过 <code>thunk-middleware</code> 来处理这类 action，把函数当作普通的 action dispatch 就好了，比如 <code>dispatch(fetchList())</code></p>\n<h2>Store</h2>\n<p>我们用一个独立的 <code>./store.js</code>，配置（比如 Apply Middleware）生成 Store</p>\n<pre class=\"prettyprint language-javascript\"><code>import { createStore } from &#x27;redux&#x27;;\nimport rootReducer from &#x27;.&#x2F;reducers&#x27;;\n\n&#x2F;&#x2F; Apply middleware here\n&#x2F;&#x2F; ...\n\nexport default function configureStore(initialState) {\n  const store = createStore(rootReducer, initialState);\n  return store;\n}\n</code></pre><h2>react-redux</h2>\n<p>接下来实现 <code>&lt;List&gt;</code>，<code>&lt;Item&gt;</code> 组件，然后把 redux 和 react 组件关联起来，具体细节参见 <a href=\"https://github.com/rackt/react-redux\">react-redux</a></p>\n<p><code>./app.js</code></p>\n<pre class=\"prettyprint language-javascript\"><code>import React from &#x27;react&#x27;;\nimport { render } from &#x27;react-dom&#x27;;\nimport { Router } from &#x27;react-router&#x27;;\nimport createBrowserHistory from &#x27;history&#x2F;lib&#x2F;createBrowserHistory&#x27;;\nimport { Provider } from &#x27;react-redux&#x27;;\nimport routes from &#x27;.&#x2F;routes&#x27;;\nimport configureStore from &#x27;.&#x2F;store&#x27;;\n\n&#x2F;&#x2F; &#96;__INITIAL_STATE__&#96; 来自服务器端渲染，下一部分细说\nconst initialState = window.__INITIAL_STATE__;\nconst store = configureStore(initialState);\nconst Root = (props) =&gt; {\n  return (\n    &lt;div&gt;\n      &lt;Provider store={store}&gt;\n        &lt;Router history={createBrowserHistory()}&gt;\n          {routes}\n        &lt;&#x2F;Router&gt;\n      &lt;&#x2F;Provider&gt;\n    &lt;&#x2F;div&gt;\n  );\n}\n\nrender(&lt;Root &#x2F;&gt;, document.getElementById(&#x27;root&#x27;));\n</code></pre><p>至此，客户端部分结束。</p>\n<h2>Server Rendering</h2>\n<p>接下来的服务器端就比较简单了，获取数据可以调用 action，routes 在服务器端的处理参考 <a href=\"https://github.com/rackt/react-router/blob/master/docs/guides/advanced/ServerRendering.md\">react-router server rendering</a>，在服务器端用一个 <code>match</code> 方法将拿到的 request url 匹配到我们之前定义的 routes，解析成和客户端一致的 props 对象传递给组件。</p>\n<p><code>./server.js</code></p>\n<pre class=\"prettyprint language-javascript\"><code>import express from &#x27;express&#x27;;\nimport React from &#x27;react&#x27;;\nimport { renderToString } from &#x27;react-dom&#x2F;server&#x27;;\nimport { RoutingContext, match } from &#x27;react-router&#x27;;\nimport { Provider } from &#x27;react-redux&#x27;;\nimport routes from &#x27;.&#x2F;routes&#x27;;\nimport configureStore from &#x27;.&#x2F;store&#x27;;\n\nconst app = express();\n\nfunction renderFullPage(html, initialState) {\n  return &#96;\n    &lt;!DOCTYPE html&gt;\n    &lt;html lang=&quot;en&quot;&gt;\n    &lt;head&gt;\n      &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;&#x2F;head&gt;\n    &lt;body&gt;\n      &lt;div id=&quot;root&quot;&gt;\n        &lt;div&gt;\n          ${html}\n        &lt;&#x2F;div&gt;\n      &lt;&#x2F;div&gt;\n      &lt;script&gt;\n        window.__INITIAL_STATE__ = ${JSON.stringify(initialState)};\n      &lt;&#x2F;script&gt;\n      &lt;script src=&quot;&#x2F;static&#x2F;bundle.js&quot;&gt;&lt;&#x2F;script&gt;\n    &lt;&#x2F;body&gt;\n    &lt;&#x2F;html&gt;\n  &#96;;\n}\n\napp.use((req, res) =&gt; {\n  match({ routes, location: req.url }, (err, redirectLocation, renderProps) =&gt; {\n    if (err) {\n      res.status(500).end(&#96;Internal Server Error ${err}&#96;);\n    } else if (redirectLocation) {\n      res.redirect(redirectLocation.pathname + redirectLocation.search);\n    } else if (renderProps) {\n      const store = configureStore();\n      const state = store.getState();\n\n      Promise.all([\n        store.dispatch(fetchList()),\n        store.dispatch(fetchItem(renderProps.params.id))\n\t  ])\n      .then(() =&gt; {\n        const html = renderToString(\n          &lt;Provider store={store}&gt;\n            &lt;RoutingContext {...renderProps} &#x2F;&gt;\n          &lt;&#x2F;Provider&gt;\n        );\n        res.end(renderFullPage(html, store.getState()));\n      });\n    } else {\n      res.status(404).end(&#x27;Not found&#x27;);\n    }\n  });\n});\n</code></pre><p>服务器端渲染部分可以直接通过共用客户端 <code>store.dispatch(action)</code> 来统一获取 Store 数据。另外注意 <code>renderFullPage</code> 生成的页面 HTML 在 React 组件 mount 的部分(<code>&lt;div id=&quot;root&quot;&gt;</code>)，前后端的 HTML 结构应该是一致的。然后要把 <code>store</code> 的状态树写入一个全局变量（<code>__INITIAL_STATE__</code>），这样客户端初始化 render 的时候能够校验服务器生成的 HTML 结构，并且同步到初始化状态，然后整个页面被客户端接管。</p>\n<h3>最后关于页面内链接跳转如何处理？</h3>\n<p>react-router 提供了一个 <code>&lt;Link&gt;</code> 组件用来替代 <code>&lt;a&gt;</code> 标签，它负责管理浏览器 history，从而不是每次点击链接都去请求服务器，然后可以通过绑定 <code>onClick</code> 事件来作其他处理。</p>\n<p>比如在 <code>/list</code> 页面，对于每一个 item 都会用 <code>&lt;Link&gt;</code> 绑定一个 route url：<code>/item/:id</code>，并且绑定 <code>onClick</code> 去触发 <code>dispatch(fetchItem(id))</code> 获取数据，显示详情页内容。</p>\n<h2>更多参考</h2>\n<ul>\n<li><a href=\"http://isomorphic.net/\">Universal (Isomorphic)</a></li>\n<li><a href=\"https://github.com/caljrimmer/isomorphic-redux-app\">isomorphic-redux-app</a></li>\n</ul>\n<p>Happy Coding,\n<a href=\"https://coding.net\">Coding.net</a></p>\n</div>","title":"玩转 React 服务器端渲染","last_reply_at":"2016-11-12T05:51:11.795Z","good":true,"top":false,"reply_count":15,"visit_count":14185,"create_at":"2015-12-04T02:22:49.618Z","author":{"loginname":"zengliqi","avatar_url":"https://avatars.githubusercontent.com/u/9347370?v=3&s=120"}},{"id":"582678ec6c4502be6ed87b61","author_id":"5826734fe885ce5a39382836","tab":"share","content":"<div class=\"markdown-text\"><h3>服务器端缓存</h3>\n<p>Web 资源在服务器和客户端（浏览器）之间的副本不仅能保存在客户端，也可以保存在服务器端。缓存会根据进来的请求将输出内容的副本保存在服务器内存中；然后，如果下一个请求是相同的 URL，且网页在这段时间内没有更新，服务器就不会再次从硬盘中获取内容，而是直接使用内存中缓存的网页副本，达到节约带宽，减少延迟的作用。</p>\n<p>下面我们将介绍一些 OnceIO 中和服务器端缓存有关的函数和属性。</p>\n<h4>服务器端缓存清空函数 app.clear()</h4>\n<p>app.clear() 能清除通过清空服务器内存删除服务器端缓存，通常会被设置为只有管理员才有权限调用，示例代码如下：</p>\n<pre class=\"prettyprint\"><code>app.get(&#x27;&#x2F;clear&#x27;, function(req, res) {\n  app.clear()\n}) \n</code></pre><p>访问 ‘/clear’ 路径，服务器端缓存将被清空。</p>\n<h4>静态文件服务器端缓存控制 fileCacheSize</h4>\n<p>fileCacheSize 是服务器端缓存静态文件的最大尺寸，超过这一尺寸的文件将不会被服务器缓存。fileCacheSize 的值可以在定义应用程序时设置，默认值为 0，即不在服务器端缓存任何静态文件，示例代码如下：</p>\n<pre class=\"prettyprint\"><code>var app = onceio({\n  fileCacheSize: 1024 * 1024\n})\n</code></pre><p>fileCacheSize 的单位是 Byte，1024 * 1024 代表 1 MB。fileCacheSize 的值建议设为 1~2 MB。如果它的值太大，OnceIO 的内存将被大量占用且压缩过程将会耗费很多时间。</p>\n<p>当一个路径第一次被访问时，OnceIO 会自动将响应中体积小于 fileCacheSize 的文件存入内存并用 gzip 将这些文件逐个压缩打包再存一份。当路径再次被访问时，服务器便可直接发送 OnceIO 内存中的文件而无需再次从硬盘中获取，此时是否发送压缩包版本则是根据用户端浏览器是否支持 gzip 决定的。</p>\n<p>一般情况下，对于每个 URL，服务器只需要对硬盘进行一次 I/O，这也是 OnceIO 名称的由来。</p>\n<p>fileCacheSize 为 0，即禁用服务器端缓存机制时，一个没有客户端缓存的客户端访问某个被其它用户访问过的路径时浏览器开发者工具中的 Network 栏效果如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/OnceDoc/images/gh-pages/OnceAcademy/cache/no_fileCacheSize_browser_network.png\" alt=\"不使用服务器内存缓存机制时 Network 栏效果\"></p>\n<p>其它条件不变，使用服务器内存缓存机制时浏览器 Network 栏效果如下，服务器用内存中的 gzip 压缩包发来响应：</p>\n<p><img src=\"https://raw.githubusercontent.com/OnceDoc/images/gh-pages/OnceAcademy/cache/fileCacheSize_set_browser_network.png\" alt=\"使用服务器内存缓存机制时 Network 栏效果\"></p>\n<p>与浏览器端缓存不同的是，服务器端缓存没有判断缓存文件有效性的功能，因此每次修改后端文件后，开发人员都需重启服务器或使用 app.clear() 清空服务器内存以确保服务器内存中的缓存总是最新的。一般情况下每次发布和布暑新版本的node应用后，重启nodejs进程都是必须的，借助redis等sesion持久化存储机制，这个重启过程可以在几秒之内完成，并且不影响当前登录用户的session会话状态。</p>\n<h4>服务器端模板文件缓存</h4>\n<h5>templateCache</h5>\n<p>templateCache 的默认值为 false，即不在服务器端缓存模板文件等动态文件。它的值可以在定义应用程序时设置，示例代码如下：</p>\n<pre class=\"prettyprint\"><code>var app = onceio({\n   templateCache: true\n})\n</code></pre><p>当 templateCache 为 true 时，模板文件会在服务器内存中被缓存。此时除非重启服务器，否则模板文件将不会被刷新。</p>\n<h5>模板嵌套和preload</h5>\n<p>模板的嵌套情况处理起来有时会比较复杂，模板可能会存在多重嵌套的情况，此时加载完所有模板需要一定的时间，OnceIO使用了一个缓存池来存储这些被嵌套的模板文件。所以用户第一次访问时缓存池为空，被嵌套的网页内容无法在第一次被渲染出来。用户需要第二次刷新才能看到完成了模板文件在缓存中的更新。这是OnceIO模板嵌套的通用代码，支持所有模板引擎。</p>\n<pre class=\"prettyprint\"><code>    &lt;!--#include=&quot;&#x2F;analytics.tmpl&quot;--&gt;\n</code></pre><p>OnceIO 内置了 preload 方法来预加载某一目录下的所有模板文件，预先加载缓存池。对当前目录下的 tmpl 后缀的文件使用 preload 的示例代码如下：</p>\n<pre class=\"prettyprint\"><code>app.preload(&#x27;.&#x27;, &#x27;.tmpl&#x27;)\n</code></pre><p>preload 的第一个参数是相对路径，示例中的 ‘.’ 代表web的home 路径，home 是 OnceIO 应用程序的一个属性，它的值可以在定义应用程序时设置，默认值为 ‘./’，即当前目录；preload 的第二个参数是文件类型，示例中的 ‘.tmpl’ 代表 tmpl 后缀的动态网页文件。</p>\n<p>使用 preload 后，即使服务器没有受到客户端的请求，也会提前加载模板文件，将其缓存在服务器内存中。在templateCache设置为true时，用户访问时服务器将不会再从硬盘读取模板文件，用户即可看到渲染完成的网页。</p>\n<p>OnceIO是<a href=\"http://oncedoc.com\">OnceDoc</a>企业私有内容(网盘)管理系统的底层Web框架，目前已开源\nOnceIO项目： <a href=\"https://github.com/OnceDoc/onceio\">https://github.com/OnceDoc/onceio</a></p>\n</div>","title":"我们为NodeJS造了一个能缓存一切的轮子：OnceIO中的服务器端缓存、模板预加载和静态资源文件的缓存和Gzip压缩机制","last_reply_at":"2016-11-12T02:05:32.007Z","good":false,"top":false,"reply_count":0,"visit_count":143,"create_at":"2016-11-12T02:05:32.007Z","author":{"loginname":"onceair","avatar_url":"https://avatars.githubusercontent.com/u/23380808?v=3&s=120"}},{"id":"582574a98e0f8bb038f38bb8","author_id":"5732f7112e11c7a80c33f8bd","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>双十一除了帮媳妇清空购物车之外，（前提是你得有）作为开发者，双十一狂欢的背后是技术层面的较量。小编整理了天猫前端 2015年双十一总结，帮助你更好了解双十一的背后，同样关注前端，更要关注在人肉 DDOS 的背后，有强大的架构支撑！明天继续带来电商的架构合集！\n记得关注标签 <a href=\"http://gold.xitu.io/tag/%E5%8F%8C%E5%8D%81%E4%B8%80\">双十一</a> 更快了解双十一热门技术文章！</p>\n</blockquote>\n<p><a href=\"http://gold.xitu.io/entry/5824882067f3560058c89960\">双11前端分享系列（一）：活动页面的性能优化 </a>\n无线优先从去年开始推行，今年更是全面无线化，双11无线业务成交拿到了不错的结果，性能也迈出了一大步，对比去年双十一页面整体load时间提升了2s秒左右，秒开率达到了70%</p>\n<p><a href=\"http://gold.xitu.io/entry/58248a51da2f60005d28e430\">双11前端分享系列(二)：天猫双11页面服务容灾方案大揭秘</a>\n会场活动页，承载了促销商品导流功能，是消费者的购物入口，在双11活动中的地位可谓重中之重。保障活动页的快速稳定可用，是非常非常重要的。这次天猫双11会场页面渲染由wormhole来承担（wormhole本身会在后续的文章中详细介绍），下面介绍一下wormhole的容灾方案。</p>\n<p><a href=\"http://gold.xitu.io/entry/58252d74570c350060d684b8\">双11前端分享系列（三）：浅谈 React Native与双11</a>\n希望能透过 react-native 的动态性，将 react native 的优势带入客户端，如手淘、手猫，让使用客户端浏览体验更佳，并且保持动态性，快速协助响应业务。</p>\n<p><a href=\"http://gold.xitu.io/entry/565c2c7b00b0bf379f1a8199\">双11前端分享系列（四）：大规模 Node.js 应用</a>\n在刚刚过去的 15 年天猫双十一中，Node.js（后文简称 node） 大放异彩，不仅帮助前端团队快速、高效的解决双十一各个业务上的页面渲染问题，同时在性能和稳定性上也表现非常出色，大大降低了双十一硬件成本的同时，在整个双十一期间未出现任何一起由 node 引发的线上故障。</p>\n<p><a href=\"http://gold.xitu.io/entry/582532ffbf22ec0068fc68be\">双11前端分享系列（五）：解密2015狂欢城 </a>\nCanvas Cache就是使用一个额外的Canvas来保存已经绘制过的内容，下一次使用的时候直接从这个Canvas上读取，这样就可以大大减少Canvas的绘制次数，例如原先首屏绘制次数约为75左右，使用cache后的次数约为28，减少了62.67%，在三四环会更明显，因为没有动画，所有内容都可以cache。</p>\n<p><a href=\"http://gold.xitu.io/entry/58253aba128fe1005a32fc91\">双11前端分享系列（六）：大规模 Node.js 应用（续）</a>\n第四篇文章讲述了我们是怎样应用 Node.js 解决模板渲染的实际问题的，而这一篇我们来看看天猫是如何一步步将 node 推广到各个业务线上的。</p>\n<p><a href=\"http://gold.xitu.io/entry/58253b7ad2030900552dd449\">双11前端分享系列（七）：如何精确识别终端</a>\n首先，要先说声抱歉，因为，其实目前我们还没有做到精确地做到识别99%的终端设别，其中原因，一部分是因为终端类型和UA实在难以覆盖，另外一部分原因也是因为使用了一些错误的识别策略。</p>\n<p><a href=\"http://gold.xitu.io/entry/58253c802e958a12992ee3d8\">双11前端分享系列（八）：双11密令红包的前端技术方案</a>\n这个玩法几乎所有的页面都需要适配Phone、Pad和PC。使用响应式开发，一套页面适配所有端曾经是我们的梦想，但是也得回归现实。不管是从设计方面，还是技术实现方面，密令红包的PC版本都与Phone版本存在着较大的差异，针对PC和Phone做两套页面的实现是无法避免的。</p>\n<p><a href=\"http://gold.xitu.io/entry/58253e542f301e005c48b00e\">双11前端分享系列（九）：vue+webpack在“双十一”导购产品的技术实践</a>\n双十一中，无线前端的产品可以说非常的丰富。在双十一中，互动始终是重头的一部分，但是与以往不一样的地方是，导购产品在本次双十一中有着不俗的表现。而今年的双11导购业务占据了5大模块里的后三个，除了必抢，其它业务均是由手淘的同学来完成的，笔者作为导购产品的一员，选择导购产品来给大家解读其中的技术实践。</p>\n<p><a href=\"http://gold.xitu.io/entry/5825425fd2030900552e0884\">双11前端分享系列（十）: 如何为用户省电</a>\n我们要做的还有很多，怎样在小细节上让用户的手机在电量上更坚挺，提升用户浏览网页的快感，让性福与高潮更持久一点，就是今天的主题了。</p>\n<p><a href=\"http://gold.xitu.io/entry/56532fe860b26267ac47ac49\">双11前端分享系列（十一）: H5性能最佳实践</a>\n手淘中大量的业务采用H5的方式开发，H5体验好坏全面影响着手淘的使用体验。今年手机淘宝在技术上重点解决“顿”，“卡”，“慢”的问题，并提出了“521法则” 。</p>\n<p>好东西记得要分享哦！当然，你也可以扫描下方二维码下载 <a href=\"http://gold.xitu.io/app\">掘金应用</a>阅读更多的技术文章。</p>\n<p><img src=\"http://ww4.sinaimg.cn/large/006y8mN6gw1f9o757yyfsj31e00rsq6n.jpg\" alt></p>\n</div>","title":"掘金双十一特辑 · 买买买的背后，电商如何做好前端优化？（一）","last_reply_at":"2016-11-12T00:44:20.299Z","good":false,"top":false,"reply_count":1,"visit_count":191,"create_at":"2016-11-11T07:35:05.507Z","author":{"loginname":"Glowin","avatar_url":"https://avatars.githubusercontent.com/u/1147941?v=3&s=120"}},{"id":"582515278e0f8bb038f38b95","author_id":"57e0ea85c4ae8ff239776db5","tab":"ask","content":"<div class=\"markdown-text\"><p>function createApplication() {\nvar app = function(req, res, next) {\napp.handle(req, res, next);\n};\n个人理解是 app在http.createServer(this)被调用，参数req，res通过createServer()触发’request’  event 传递给app函数，不太明白next是怎么来的？希望有人可以解答一下～谢谢</p>\n</div>","title":"express源码中的next参数","last_reply_at":"2016-11-11T23:47:33.537Z","good":false,"top":false,"reply_count":6,"visit_count":173,"create_at":"2016-11-11T00:47:35.987Z","author":{"loginname":"yooki0328","avatar_url":"https://avatars.githubusercontent.com/u/17794392?v=3&s=120"}},{"id":"582656dee885ce5a39382831","author_id":"54009f5ccd66f2eb37190485","tab":"share","content":"<div class=\"markdown-text\"><h2>中间件2种用法</h2>\n<ul>\n<li>筒子</li>\n<li>变胖的筒子</li>\n</ul>\n<h3>筒子</h3>\n<pre class=\"prettyprint\"><code>app.use(&#x27;&#x2F;1&#x27;, function(req, res, next){\n\n})\n\napp.use(&#x27;&#x2F;2&#x27;, function(req, res, next){\n\n})\n\napp.use(&#x27;&#x2F;3&#x27;, function(req, res, next){\n\n})\n</code></pre><h3>变胖的筒子</h3>\n<pre class=\"prettyprint\"><code>function m1(req, res, next){\n\n}\n\nfunction m2(req, res, next){\n\n}\n\napp.use(&#x27;&#x2F;&#x27;, m1, m2, function(req, res, next){\n\n})\n</code></pre><h3>路由匹配规则</h3>\n<ul>\n<li>先根据【筒子】栈，匹配到请求</li>\n<li>然后看该请求，是不是【变胖的筒子】，如果是，还需要继续解析该路由上的横向的栈</li>\n</ul>\n<h2>express的next说明</h2>\n<ul>\n<li>3.x 使用<a href=\"https://github.com/senchalabs/connect\">connect</a>作为中间件</li>\n<li>4.x 在express/lib/router/里实现router.handle(req, res, next);</li>\n<li>5.x 使用独立的<a href=\"https://github.com/pillarjs/router\">router</a>模块</li>\n</ul>\n<pre class=\"prettyprint\"><code>4.0.0 &#x2F; 2014-04-09\n==================\n\n * remove:\n   - node 0.8 support\n   - connect and connect&#x27;s patches except for charset handling\n   - express(1) - moved to [express-generator](https:&#x2F;&#x2F;github.com&#x2F;expressjs&#x2F;generator)\n   - &#96;express.createServer()&#96; - it has been deprecated for a long time. Use &#96;express()&#96;\n   - &#96;app.configure&#96; - use logic in your own app code\n   - &#96;app.router&#96; - is removed\n   - &#96;req.auth&#96; - use &#96;basic-auth&#96; instead\n   - &#96;req.accepted*&#96; - use &#96;req.accepts*()&#96; instead\n   - &#96;res.location&#96; - relative URL resolution is removed\n   - &#96;res.charset&#96; - include the charset in the content type when using &#96;res.set()&#96;\n   - all bundled middleware except &#96;static&#96;\n * change:\n   - &#96;app.route&#96; -&gt; &#96;app.mountpath&#96; when mounting an express app in another express app\n   - &#96;json spaces&#96; no longer enabled by default in development\n   - &#96;req.accepts*&#96; -&gt; &#96;req.accepts*s&#96; - i.e. &#96;req.acceptsEncoding&#96; -&gt; &#96;req.acceptsEncodings&#96;\n   - &#96;req.params&#96; is now an object instead of an array\n   - &#96;res.locals&#96; is no longer a function. It is a plain js object. Treat it as such.\n   - &#96;res.headerSent&#96; -&gt; &#96;res.headersSent&#96; to match node.js ServerResponse object\n * refactor:\n   - &#96;req.accepts*&#96; with [accepts](https:&#x2F;&#x2F;github.com&#x2F;expressjs&#x2F;accepts)\n   - &#96;req.is&#96; with [type-is](https:&#x2F;&#x2F;github.com&#x2F;expressjs&#x2F;type-is)\n   - [path-to-regexp](https:&#x2F;&#x2F;github.com&#x2F;component&#x2F;path-to-regexp)\n * add:\n   - &#96;app.router()&#96; - returns the app Router instance\n   - &#96;app.route()&#96; - Proxy to the app&#x27;s &#96;Router#route()&#96; method to create a new route\n   - Router &amp; Route - public API\n</code></pre><p>大家知道变更即可，过多细节也没啥用</p>\n<h2>express里的use</h2>\n<p>主要2个</p>\n<ul>\n<li>app.use</li>\n<li>还有router.use</li>\n</ul>\n<h3>给出application里的use实现</h3>\n<pre class=\"prettyprint\"><code>app.use = function use(fn) {\n  var offset = 0;\n  var path = &#x27;&#x2F;&#x27;;\n\n  &#x2F;&#x2F; default path to &#x27;&#x2F;&#x27;\n  &#x2F;&#x2F; disambiguate app.use([fn])\n  if (typeof fn !== &#x27;function&#x27;) {\n    var arg = fn;\n\n    while (Array.isArray(arg) &amp;&amp; arg.length !== 0) {\n      arg = arg[0];\n    }\n\n    &#x2F;&#x2F; first arg is the path\n    if (typeof arg !== &#x27;function&#x27;) {\n      offset = 1;\n      path = fn;\n    }\n  }\n\n  var fns = flatten(slice.call(arguments, offset));\n\n  if (fns.length === 0) {\n    throw new TypeError(&#x27;app.use() requires middleware functions&#x27;);\n  }\n\n  &#x2F;&#x2F; setup router\n  this.lazyrouter();\n  var router = this._router;\n\n  fns.forEach(function (fn) {\n    &#x2F;&#x2F; non-express app\n    if (!fn || !fn.handle || !fn.set) {\n      return router.use(path, fn);\n    }\n\n    debug(&#x27;.use app under %s&#x27;, path);\n    fn.mountpath = path;\n    fn.parent = this;\n\n    &#x2F;&#x2F; restore .app property on req and res\n    router.use(path, function mounted_app(req, res, next) {\n      var orig = req.app;\n      fn.handle(req, res, function (err) {\n        req.__proto__ = orig.request;\n        res.__proto__ = orig.response;\n        next(err);\n      });\n    });\n\n    &#x2F;&#x2F; mounted an app\n    fn.emit(&#x27;mount&#x27;, this);\n  }, this);\n\n  return this;\n};\n</code></pre><p>简单点说就是把中间件变成了路由来处理。</p>\n<p>所有的fns中间件都被router.use真正处理了</p>\n<pre class=\"prettyprint\"><code>router.use(path, function mounted_app(req, res, next) {\n  var orig = req.app;\n  fn.handle(req, res, function (err) {\n    req.__proto__ = orig.request;\n    res.__proto__ = orig.response;\n    next(err);\n  });\n});\n</code></pre><h3>给出router里use实现</h3>\n<pre class=\"prettyprint\"><code>&#x2F;**\n * Use the given middleware function, with optional path, defaulting to &quot;&#x2F;&quot;.\n *\n * Use (like &#96;.all&#96;) will run for any http METHOD, but it will not add\n * handlers for those methods so OPTIONS requests will not consider &#96;.use&#96;\n * functions even if they could respond.\n *\n * The other difference is that _route_ path is stripped and not visible\n * to the handler function. The main effect of this feature is that mounted\n * handlers can operate without any code changes regardless of the &quot;prefix&quot;\n * pathname.\n *\n * @public\n *&#x2F;\n\nproto.use = function use(fn) {\n  var offset = 0;\n  var path = &#x27;&#x2F;&#x27;;\n\n  &#x2F;&#x2F; default path to &#x27;&#x2F;&#x27;\n  &#x2F;&#x2F; disambiguate router.use([fn])\n  if (typeof fn !== &#x27;function&#x27;) {\n    var arg = fn;\n\n    while (Array.isArray(arg) &amp;&amp; arg.length !== 0) {\n      arg = arg[0];\n    }\n\n    &#x2F;&#x2F; first arg is the path\n    if (typeof arg !== &#x27;function&#x27;) {\n      offset = 1;\n      path = fn;\n    }\n  }\n\n  var callbacks = flatten(slice.call(arguments, offset));\n\n  if (callbacks.length === 0) {\n    throw new TypeError(&#x27;Router.use() requires middleware functions&#x27;);\n  }\n\n  for (var i = 0; i &lt; callbacks.length; i++) {\n    var fn = callbacks[i];\n\n    if (typeof fn !== &#x27;function&#x27;) {\n      throw new TypeError(&#x27;Router.use() requires middleware function but got a &#x27; + gettype(fn));\n    }\n\n    &#x2F;&#x2F; add the middleware\n    debug(&#x27;use %s %s&#x27;, path, fn.name || &#x27;&lt;anonymous&gt;&#x27;);\n\n    var layer = new Layer(path, {\n      sensitive: this.caseSensitive,\n      strict: false,\n      end: false\n    }, fn);\n\n    layer.route = undefined;\n\n    this.stack.push(layer);\n  }\n\n  return this;\n};\n</code></pre><ol>\n<li>把参数搞成callbacks</li>\n</ol>\n<pre class=\"prettyprint\"><code>  var callbacks = flatten(slice.call(arguments, offset));\n</code></pre><ol>\n<li>遍历callback，转成中间件</li>\n</ol>\n<pre class=\"prettyprint\"><code>    var layer = new Layer(path, {\n      sensitive: this.caseSensitive,\n      strict: false,\n      end: false\n    }, fn);\n\n    layer.route = undefined;\n</code></pre><ol>\n<li>入栈</li>\n</ol>\n<pre class=\"prettyprint\"><code>    this.stack.push(layer);\n</code></pre><p>总结一下：核心还是在Layer里</p>\n<h2>Layer</h2>\n<p>layer代码非常少，也就100多，方法不过5个</p>\n<p>构造函数</p>\n<pre class=\"prettyprint\"><code>function Layer(path, options, fn) {\n  if (!(this instanceof Layer)) {\n    return new Layer(path, options, fn);\n  }\n\n  debug(&#x27;new %s&#x27;, path);\n  var opts = options || {};\n\n  this.handle = fn;\n  this.name = fn.name || &#x27;&lt;anonymous&gt;&#x27;;\n  this.params = undefined;\n  this.path = undefined;\n  this.regexp = pathRegexp(path, this.keys = [], opts);\n\n  if (path === &#x27;&#x2F;&#x27; &amp;&amp; opts.end === false) {\n    this.regexp.fast_slash = true;\n  }\n}\n</code></pre><p>主要看看this上有那些变量，这是一个请求会产生处理的。比如name我们在遍历中间件的时候可能会出现anonymous，原因就在这里。</p>\n<p>通过pathRegexp进行匹配url，然后把fn处理了，很明显这是单个的或者说是final的处理。</p>\n<pre class=\"prettyprint\"><code>var pathRegexp = require(&#x27;path-to-regexp&#x27;);\n</code></pre><ul>\n<li>handle_error</li>\n<li>handle_request</li>\n</ul>\n<pre class=\"prettyprint\"><code>Layer.prototype.handle_request = function handle(req, res, next) {\n  var fn = this.handle;\n\n  if (fn.length &gt; 3) {\n    &#x2F;&#x2F; not a standard request handler\n    return next();\n  }\n\n  try {\n    fn(req, res, next);\n  } catch (err) {\n    next(err);\n  }\n};\n</code></pre><h2>不知道大家是否好奇</h2>\n<p>给出express 4.x里的express/lib/router/index.js里的实现</p>\n<pre class=\"prettyprint\"><code>proto.handle = function handle(req, res, out) {\n  var self = this;\n\n  debug(&#x27;dispatching %s %s&#x27;, req.method, req.url);\n\n  var search = 1 + req.url.indexOf(&#x27;?&#x27;);\n  var pathlength = search ? search - 1 : req.url.length;\n  var fqdn = req.url[0] !== &#x27;&#x2F;&#x27; &amp;&amp; 1 + req.url.substr(0, pathlength).indexOf(&#x27;:&#x2F;&#x2F;&#x27;);\n  var protohost = fqdn ? req.url.substr(0, req.url.indexOf(&#x27;&#x2F;&#x27;, 2 + fqdn)) : &#x27;&#x27;;\n  var idx = 0;\n  var removed = &#x27;&#x27;;\n  var slashAdded = false;\n  var paramcalled = {};\n\n  &#x2F;&#x2F; store options for OPTIONS request\n  &#x2F;&#x2F; only used if OPTIONS request\n  var options = [];\n\n  &#x2F;&#x2F; middleware and routes\n  var stack = self.stack;\n\n  &#x2F;&#x2F; manage inter-router variables\n  var parentParams = req.params;\n  var parentUrl = req.baseUrl || &#x27;&#x27;;\n  var done = restore(out, req, &#x27;baseUrl&#x27;, &#x27;next&#x27;, &#x27;params&#x27;);\n\n  &#x2F;&#x2F; setup next layer\n  req.next = next;\n\n  &#x2F;&#x2F; for options requests, respond with a default if nothing else responds\n  if (req.method === &#x27;OPTIONS&#x27;) {\n    done = wrap(done, function(old, err) {\n      if (err || options.length === 0) return old(err);\n      sendOptionsResponse(res, options, old);\n    });\n  }\n\n  &#x2F;&#x2F; setup basic req values\n  req.baseUrl = parentUrl;\n  req.originalUrl = req.originalUrl || req.url;\n\n  next();\n\n  function next(err) {\n    var layerError = err === &#x27;route&#x27;\n      ? null\n      : err;\n\n    &#x2F;&#x2F; remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    &#x2F;&#x2F; restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = &#x27;&#x27;;\n    }\n\n    &#x2F;&#x2F; no more matching layers\n    if (idx &gt;= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    &#x2F;&#x2F; get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    &#x2F;&#x2F; find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true &amp;&amp; idx &lt; stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== &#x27;boolean&#x27;) {\n        &#x2F;&#x2F; hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        &#x2F;&#x2F; process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        &#x2F;&#x2F; routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      &#x2F;&#x2F; build up automatic options response\n      if (!has_method &amp;&amp; method === &#x27;OPTIONS&#x27;) {\n        appendMethods(options, route._options());\n      }\n\n      &#x2F;&#x2F; don&#x27;t even bother matching route\n      if (!has_method &amp;&amp; method !== &#x27;HEAD&#x27;) {\n        match = false;\n        continue;\n      }\n    }\n\n    &#x2F;&#x2F; no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    &#x2F;&#x2F; store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    &#x2F;&#x2F; Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    &#x2F;&#x2F; this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  }\n\n  function trim_prefix(layer, layerError, layerPath, path) {\n    var c = path[layerPath.length];\n    if (c &amp;&amp; &#x27;&#x2F;&#x27; !== c &amp;&amp; &#x27;.&#x27; !== c) return next(layerError);\n\n     &#x2F;&#x2F; Trim off the part of the url that matches the route\n     &#x2F;&#x2F; middleware (.use stuff) needs to have the path stripped\n    if (layerPath.length !== 0) {\n      debug(&#x27;trim prefix (%s) from url %s&#x27;, layerPath, req.url);\n      removed = layerPath;\n      req.url = protohost + req.url.substr(protohost.length + removed.length);\n\n      &#x2F;&#x2F; Ensure leading slash\n      if (!fqdn &amp;&amp; req.url[0] !== &#x27;&#x2F;&#x27;) {\n        req.url = &#x27;&#x2F;&#x27; + req.url;\n        slashAdded = true;\n      }\n\n      &#x2F;&#x2F; Setup base URL (no trailing slash)\n      req.baseUrl = parentUrl + (removed[removed.length - 1] === &#x27;&#x2F;&#x27;\n        ? removed.substring(0, removed.length - 1)\n        : removed);\n    }\n\n    debug(&#x27;%s %s : %s&#x27;, layer.name, layerPath, req.originalUrl);\n\n    if (layerError) {\n      layer.handle_error(layerError, req, res, next);\n    } else {\n      layer.handle_request(req, res, next);\n    }\n  }\n};\n\n</code></pre><h3>核心在next();方法</h3>\n<pre class=\"prettyprint\"><code>    while (match !== true &amp;&amp; idx &lt; stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== &#x27;boolean&#x27;) {\n        &#x2F;&#x2F; hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        &#x2F;&#x2F; process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        &#x2F;&#x2F; routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      &#x2F;&#x2F; build up automatic options response\n      if (!has_method &amp;&amp; method === &#x27;OPTIONS&#x27;) {\n        appendMethods(options, route._options());\n      }\n\n      &#x2F;&#x2F; don&#x27;t even bother matching route\n      if (!has_method &amp;&amp; method !== &#x27;HEAD&#x27;) {\n        match = false;\n        continue;\n      }\n    }\n</code></pre><p>看到这个</p>\n<pre class=\"prettyprint\"><code>layer = stack[idx++];\n</code></pre><p>你会想到什么？遍历栈要做什么呢？</p>\n<p>一个路由，其实就是stack，可以1个也可以多个中间件，想想上面说的“先根据【筒子】栈，匹配到请求”</p>\n<p>然后，根据遍历结果，match和route来处理。只有匹配了路由，才会走到具体的处理</p>\n<pre class=\"prettyprint\"><code>    &#x2F;&#x2F; no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    &#x2F;&#x2F; store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    &#x2F;&#x2F; Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    &#x2F;&#x2F; this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n</code></pre><p>整体来说，设计的职责清晰，还算是比较精巧的。代码的可读性能做到这样，还是真的很难得的，推荐学习。</p>\n</div>","title":"express中间件机制补充说明","last_reply_at":"2016-11-11T23:46:03.098Z","good":false,"top":false,"reply_count":1,"visit_count":124,"create_at":"2016-11-11T23:40:14.853Z","author":{"loginname":"i5ting","avatar_url":"https://avatars.githubusercontent.com/u/3118295?v=3&s=120"}},{"id":"57ff5c82487e1e4578afb4b4","author_id":"548a5f1557fd3ae46b233385","tab":"job","content":"<div class=\"markdown-text\"><p><strong>岗位职责</strong>：</p>\n<ol>\n<li>负责 API的开发和改进；</li>\n<li>负责管理后台的开发；</li>\n<li>负责统计系统的设计和开发；</li>\n</ol>\n<p><strong>任职要求</strong>：</p>\n<ol>\n<li>全日制统招本科及以上学历，计算机等相关专业；</li>\n<li>一年以上Node.js开发经验，熟悉Express框架；</li>\n<li>理解异步回调的编程模型，掌握至少一种异步控制流程框架(async、bluebird、Q等)；</li>\n<li>至少熟悉一种JavaScript MVC架构如Vue.js, Angular.js, Backbone.js；</li>\n<li>了解NoSQL数据库，了解Redis缓存，熟悉MongoDB者优先考虑；</li>\n<li>对全栈编程有热情， 理解常见设计模式，自学能力强，能阅读英文材料；</li>\n<li>有移动直播项目的经验或技术blog和开源项目经验者优先；</li>\n<li>工作积极主动，有责任心，具备团队协作精神，执行力和抗压能力较强。</li>\n</ol>\n<p><strong>公司介绍</strong>:\n美豆TV是国内首家高端VR直播平台，以明星、社会名人、正能量网红、美豆签约艺人为主播主体，进行全景空间VR展示，可多人同场同线直播，自制优质综艺娱乐栏目，传递阳光正能量。艺人云集+VR黑科技+优质内容= 美豆TV\n<strong>工作地址</strong>：北京市东城区北三环东路环球贸易中心A座9层\n<strong>公司网址</strong>：<a href=\"http://www.superd3d.com\">www.superd3d.com</a>\n<strong>薪资水平</strong>：10000-25000（看您的技术水平）\n<strong>福利水平</strong>：五险一金，员工旅游，带薪年假，节日福利，欢乐氛围\n有意者可将简历发送至：<strong><a href=\"mailto:ting.liu@superd3d.com\">ting.liu@superd3d.com</a>(请不要在邮件中粘贴附件，务必在邮件主题处注明应聘职位名称、工作地点及招聘来源)</strong></p>\n</div>","title":"[北京]星辰美豆招聘招聘node.js程序员2名","last_reply_at":"2016-11-11T15:07:34.113Z","good":false,"top":false,"reply_count":7,"visit_count":378,"create_at":"2016-10-13T10:05:54.820Z","author":{"loginname":"eqiuno","avatar_url":"https://avatars.githubusercontent.com/u/180689?v=3&s=120"}}]}